require open hol-light.theory_hol;
require open hol-light.hol_types;
require open hol-light.hol_terms;
symbol lem8423332 [A B P] : Prf (∀ (λ clauses : El (list (prod (fun P A) (fun (fun A B) (fun P B)))), (⇒ (∧ (∃ (λ << : El (fun A (fun A bool)), (∧ ((@WF A) <<) ((@ALL (prod (fun P A) (fun (fun A B) (fun P B)))) ((@GABS (fun (prod (fun P A) (fun (fun A B) (fun P B))) bool)) (λ f : El (fun (prod (fun P A) (fun (fun A B) (fun P B))) bool), (∀ (λ s : El (fun P A), (∀ (λ t : El (fun (fun A B) (fun P B)), ((@GEQ bool) (f ((@̦‚ (fun P A) (fun (fun A B) (fun P B))) s t)) ((@tailadmissible A B P) << (λ f' : El (fun A B), (λ a : El P, T)) s t)))))))) clauses)))) (∀ (λ s : El (fun P A), (∀ (λ t : El (fun (fun A B) (fun P B)), (∀ (λ s' : El (fun P A), (∀ (λ t' : El (fun (fun A B) (fun P B)), (∀ (λ f : El (fun A B), (∀ (λ x : El P, (∀ (λ y : El P, (⇒ (∧ ((@MEM (prod (fun P A) (fun (fun A B) (fun P B)))) ((@̦‚ (fun P A) (fun (fun A B) (fun P B))) s t) clauses) ((@MEM (prod (fun P A) (fun (fun A B) (fun P B)))) ((@̦‚ (fun P A) (fun (fun A B) (fun P B))) s' t') clauses)) (⇒ (= (s x) (s' y)) (= (t f x) (t' f y))))))))))))))))))) (∃ (λ f : El (fun A B), ((@ALL (prod (fun P A) (fun (fun A B) (fun P B)))) ((@GABS (fun (prod (fun P A) (fun (fun A B) (fun P B))) bool)) (λ f' : El (fun (prod (fun P A) (fun (fun A B) (fun P B))) bool), (∀ (λ s : El (fun P A), (∀ (λ t : El (fun (fun A B) (fun P B)), ((@GEQ bool) (f' ((@̦‚ (fun P A) (fun (fun A B) (fun P B))) s t)) (∀ (λ x : El P, (= (f (s x)) (t f x))))))))))) clauses))))));
