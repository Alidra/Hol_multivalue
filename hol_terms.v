Require Import coq.
Require Import theory_hol.
Require Import hol_types.
Definition _FALSITY_ : Prop := False.
Lemma _FALSITY__def : _FALSITY_ = False.
Proof. exact (eq_refl _FALSITY_). Qed.
Lemma COND_def {A : Type'} : (@COND A) = (fun t : Prop => fun t1 : A => fun t2 : A => @ε A (fun x : A => ((t = True) -> x = t1) /\ ((t = False) -> x = t2))).
Proof. exact (eq_refl (@COND A)). Qed.
Definition o {A B C : Type'} : (B -> C) -> (A -> B) -> A -> C := fun f : B -> C => fun g : A -> B => fun x : A => f (g x).
Lemma o_def {A B C : Type'} : (@o A B C) = (fun f : B -> C => fun g : A -> B => fun x : A => f (g x)).
Proof. exact (eq_refl (@o A B C)). Qed.
Definition I {A : Type'} : A -> A := fun x : A => x.
Lemma I_def {A : Type'} : (@I A) = (fun x : A => x).
Proof. exact (eq_refl (@I A)). Qed.
Definition hashek : Prop := True.
Lemma hashek_def : hashek = True.
Proof. exact (eq_refl hashek). Qed.
Definition LET {A B : Type'} : (A -> B) -> A -> B := fun f : A -> B => fun x : A => f x.
Lemma LET_def {A B : Type'} : (@LET A B) = (fun f : A -> B => fun x : A => f x).
Proof. exact (eq_refl (@LET A B)). Qed.
Definition LET_END {A : Type'} : A -> A := fun t : A => t.
Lemma LET_END_def {A : Type'} : (@LET_END A) = (fun t : A => t).
Proof. exact (eq_refl (@LET_END A)). Qed.
Definition GABS {A : Type'} : (A -> Prop) -> A := fun P : A -> Prop => @ε A P.
Lemma GABS_def {A : Type'} : (@GABS A) = (fun P : A -> Prop => @ε A P).
Proof. exact (eq_refl (@GABS A)). Qed.
Definition GEQ {A : Type'} : A -> A -> Prop := fun a : A => fun b : A => a = b.
Lemma GEQ_def {A : Type'} : (@GEQ A) = (fun a : A => fun b : A => a = b).
Proof. exact (eq_refl (@GEQ A)). Qed.
Definition _SEQPATTERN {_4611 _4614 : Type'} : (_4614 -> _4611 -> Prop) -> (_4614 -> _4611 -> Prop) -> _4614 -> _4611 -> Prop := fun r : _4614 -> _4611 -> Prop => fun s : _4614 -> _4611 -> Prop => fun x : _4614 => @COND (_4611 -> Prop) (exists y : _4611, r x y) (r x) (s x).
Lemma _SEQPATTERN_def {_4611 _4614 : Type'} : (@_SEQPATTERN _4611 _4614) = (fun r : _4614 -> _4611 -> Prop => fun s : _4614 -> _4611 -> Prop => fun x : _4614 => @COND (_4611 -> Prop) (exists y : _4611, r x y) (r x) (s x)).
Proof. exact (eq_refl (@_SEQPATTERN _4611 _4614)). Qed.
Definition _UNGUARDED_PATTERN : Prop -> Prop -> Prop := fun p : Prop => fun r : Prop => p /\ r.
Lemma _UNGUARDED_PATTERN_def : _UNGUARDED_PATTERN = (fun p : Prop => fun r : Prop => p /\ r).
Proof. exact (eq_refl _UNGUARDED_PATTERN). Qed.
Definition _GUARDED_PATTERN : Prop -> Prop -> Prop -> Prop := fun p : Prop => fun g : Prop => fun r : Prop => p /\ (g /\ r).
Lemma _GUARDED_PATTERN_def : _GUARDED_PATTERN = (fun p : Prop => fun g : Prop => fun r : Prop => p /\ (g /\ r)).
Proof. exact (eq_refl _GUARDED_PATTERN). Qed.
Definition _MATCH {_4656 _4660 : Type'} : _4656 -> (_4656 -> _4660 -> Prop) -> _4660 := fun e : _4656 => fun r : _4656 -> _4660 -> Prop => @COND _4660 (@ex1 _4660 (r e)) (@ε _4660 (r e)) (@ε _4660 (fun z : _4660 => False)).
Lemma _MATCH_def {_4656 _4660 : Type'} : (@_MATCH _4656 _4660) = (fun e : _4656 => fun r : _4656 -> _4660 -> Prop => @COND _4660 (@ex1 _4660 (r e)) (@ε _4660 (r e)) (@ε _4660 (fun z : _4660 => False))).
Proof. exact (eq_refl (@_MATCH _4656 _4660)). Qed.
Definition _FUNCTION {_4678 _4682 : Type'} : (_4678 -> _4682 -> Prop) -> _4678 -> _4682 := fun r : _4678 -> _4682 -> Prop => fun x : _4678 => @COND _4682 (@ex1 _4682 (r x)) (@ε _4682 (r x)) (@ε _4682 (fun z : _4682 => False)).
Lemma _FUNCTION_def {_4678 _4682 : Type'} : (@_FUNCTION _4678 _4682) = (fun r : _4678 -> _4682 -> Prop => fun x : _4678 => @COND _4682 (@ex1 _4682 (r x)) (@ε _4682 (r x)) (@ε _4682 (fun z : _4682 => False))).
Proof. exact (eq_refl (@_FUNCTION _4678 _4682)). Qed.
Lemma mk_pair_def {A B : Type'} : (@mk_pair A B) = (fun x : A => fun y : B => fun a : A => fun b : B => (a = x) /\ (b = y)).
Proof. exact (eq_refl (@mk_pair A B)). Qed.
Definition CURRY {A B C : Type'} : ((prod A B) -> C) -> A -> B -> C := fun _1283 : (prod A B) -> C => fun _1284 : A => fun _1285 : B => _1283 (@pair A B _1284 _1285).
Lemma CURRY_def {A B C : Type'} : (@CURRY A B C) = (fun _1283 : (prod A B) -> C => fun _1284 : A => fun _1285 : B => _1283 (@pair A B _1284 _1285)).
Proof. exact (eq_refl (@CURRY A B C)). Qed.
Definition UNCURRY {A B C : Type'} : (A -> B -> C) -> (prod A B) -> C := fun _1304 : A -> B -> C => fun _1305 : prod A B => _1304 (@fst A B _1305) (@snd A B _1305).
Lemma UNCURRY_def {A B C : Type'} : (@UNCURRY A B C) = (fun _1304 : A -> B -> C => fun _1305 : prod A B => _1304 (@fst A B _1305) (@snd A B _1305)).
Proof. exact (eq_refl (@UNCURRY A B C)). Qed.
Definition PASSOC {A B C D : Type'} : ((prod (prod A B) C) -> D) -> (prod A (prod B C)) -> D := fun _1321 : (prod (prod A B) C) -> D => fun _1322 : prod A (prod B C) => _1321 (@pair (prod A B) C (@pair A B (@fst A (prod B C) _1322) (@fst B C (@snd A (prod B C) _1322))) (@snd B C (@snd A (prod B C) _1322))).
Lemma PASSOC_def {A B C D : Type'} : (@PASSOC A B C D) = (fun _1321 : (prod (prod A B) C) -> D => fun _1322 : prod A (prod B C) => _1321 (@pair (prod A B) C (@pair A B (@fst A (prod B C) _1322) (@fst B C (@snd A (prod B C) _1322))) (@snd B C (@snd A (prod B C) _1322)))).
Proof. exact (eq_refl (@PASSOC A B C D)). Qed.
Lemma ONE_ONE_def {A B : Type'} : (@ONE_ONE A B) = (fun _2064 : A -> B => forall x1 : A, forall x2 : A, ((_2064 x1) = (_2064 x2)) -> x1 = x2).
Proof. exact (eq_refl (@ONE_ONE A B)). Qed.
Lemma ONTO_def {A B : Type'} : (@ONTO A B) = (fun _2069 : A -> B => forall y : B, exists x : A, y = (_2069 x)).
Proof. exact (eq_refl (@ONTO A B)). Qed.
Lemma IND_SUC_def : IND_SUC = (@ε (ind -> ind) (fun f : ind -> ind => exists z : ind, (forall x1 : ind, forall x2 : ind, ((f x1) = (f x2)) = (x1 = x2)) /\ (forall x : ind, ~ ((f x) = z)))).
Proof. exact (eq_refl IND_SUC). Qed.
Lemma IND_0_def : IND_0 = (@ε ind (fun z : ind => (forall x1 : ind, forall x2 : ind, ((IND_SUC x1) = (IND_SUC x2)) = (x1 = x2)) /\ (forall x : ind, ~ ((IND_SUC x) = z)))).
Proof. exact (eq_refl IND_0). Qed.
Lemma NUM_REP_def : NUM_REP = (fun a : ind => forall NUM_REP' : ind -> Prop, (forall a' : ind, ((a' = IND_0) \/ (exists i : ind, (a' = (IND_SUC i)) /\ (NUM_REP' i))) -> NUM_REP' a') -> NUM_REP' a).
Proof. exact (eq_refl NUM_REP). Qed.
Definition NUMERAL : nat -> nat := fun _2128 : nat => _2128.
Lemma NUMERAL_def : NUMERAL = (fun _2128 : nat => _2128).
Proof. exact (eq_refl NUMERAL). Qed.
Lemma BIT1_def : BIT1 = (fun _2143 : nat => S (BIT0 _2143)).
Proof. exact (eq_refl BIT1). Qed.
Definition minimal : (nat -> Prop) -> nat := fun _6373 : nat -> Prop => @ε nat (fun n : nat => (_6373 n) /\ (forall m : nat, (Peano.lt m n) -> ~ (_6373 m))).
Lemma minimal_def : minimal = (fun _6373 : nat -> Prop => @ε nat (fun n : nat => (_6373 n) /\ (forall m : nat, (Peano.lt m n) -> ~ (_6373 m)))).
Proof. exact (eq_refl minimal). Qed.
Definition WF {A : Type'} : (A -> A -> Prop) -> Prop := fun _6760 : A -> A -> Prop => forall P : A -> Prop, (exists x : A, P x) -> exists x : A, (P x) /\ (forall y : A, (_6760 y x) -> ~ (P y)).
Lemma WF_def {A : Type'} : (@WF A) = (fun _6760 : A -> A -> Prop => forall P : A -> Prop, (exists x : A, P x) -> exists x : A, (P x) /\ (forall y : A, (_6760 y x) -> ~ (P y))).
Proof. exact (eq_refl (@WF A)). Qed.
Definition MEASURE {_16406 : Type'} : (_16406 -> nat) -> _16406 -> _16406 -> Prop := fun _7931 : _16406 -> nat => fun x : _16406 => fun y : _16406 => Peano.lt (_7931 x) (_7931 y).
Lemma MEASURE_def {_16406 : Type'} : (@MEASURE _16406) = (fun _7931 : _16406 -> nat => fun x : _16406 => fun y : _16406 => Peano.lt (_7931 x) (_7931 y)).
Proof. exact (eq_refl (@MEASURE _16406)). Qed.
Definition NUMPAIR : nat -> nat -> nat := fun _17324 : nat => fun _17325 : nat => Nat.mul (Nat.pow (NUMERAL (BIT0 (BIT1 0))) _17324) (Nat.add (Nat.mul (NUMERAL (BIT0 (BIT1 0))) _17325) (NUMERAL (BIT1 0))).
Lemma NUMPAIR_def : NUMPAIR = (fun _17324 : nat => fun _17325 : nat => Nat.mul (Nat.pow (NUMERAL (BIT0 (BIT1 0))) _17324) (Nat.add (Nat.mul (NUMERAL (BIT0 (BIT1 0))) _17325) (NUMERAL (BIT1 0)))).
Proof. exact (eq_refl NUMPAIR). Qed.
Definition NUMFST : nat -> nat := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat) (fun X : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat => forall _17340 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), exists Y : nat -> nat, forall x : nat, forall y : nat, ((X _17340 (NUMPAIR x y)) = x) /\ ((Y (NUMPAIR x y)) = y)) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0))))))))))))).
Lemma NUMFST_def : NUMFST = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat) (fun X : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat => forall _17340 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), exists Y : nat -> nat, forall x : nat, forall y : nat, ((X _17340 (NUMPAIR x y)) = x) /\ ((Y (NUMPAIR x y)) = y)) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))))))))).
Proof. exact (eq_refl NUMFST). Qed.
Definition NUMSND : nat -> nat := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat) (fun Y : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat => forall _17341 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), forall x : nat, forall y : nat, ((NUMFST (NUMPAIR x y)) = x) /\ ((Y _17341 (NUMPAIR x y)) = y)) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0))))))))))))).
Lemma NUMSND_def : NUMSND = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat) (fun Y : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat => forall _17341 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), forall x : nat, forall y : nat, ((NUMFST (NUMPAIR x y)) = x) /\ ((Y _17341 (NUMPAIR x y)) = y)) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))))))))).
Proof. exact (eq_refl NUMSND). Qed.
Definition NUMSUM : Prop -> nat -> nat := fun _17342 : Prop => fun _17343 : nat => @COND nat _17342 (S (Nat.mul (NUMERAL (BIT0 (BIT1 0))) _17343)) (Nat.mul (NUMERAL (BIT0 (BIT1 0))) _17343).
Lemma NUMSUM_def : NUMSUM = (fun _17342 : Prop => fun _17343 : nat => @COND nat _17342 (S (Nat.mul (NUMERAL (BIT0 (BIT1 0))) _17343)) (Nat.mul (NUMERAL (BIT0 (BIT1 0))) _17343)).
Proof. exact (eq_refl NUMSUM). Qed.
Definition INJN {A : Type'} : nat -> nat -> A -> Prop := fun _17374 : nat => fun n : nat => fun a : A => n = _17374.
Lemma INJN_def {A : Type'} : (@INJN A) = (fun _17374 : nat => fun n : nat => fun a : A => n = _17374).
Proof. exact (eq_refl (@INJN A)). Qed.
Definition INJA {A : Type'} : A -> nat -> A -> Prop := fun _17379 : A => fun n : nat => fun b : A => b = _17379.
Lemma INJA_def {A : Type'} : (@INJA A) = (fun _17379 : A => fun n : nat => fun b : A => b = _17379).
Proof. exact (eq_refl (@INJA A)). Qed.
Definition INJF {A : Type'} : (nat -> nat -> A -> Prop) -> nat -> A -> Prop := fun _17386 : nat -> nat -> A -> Prop => fun n : nat => _17386 (NUMFST n) (NUMSND n).
Lemma INJF_def {A : Type'} : (@INJF A) = (fun _17386 : nat -> nat -> A -> Prop => fun n : nat => _17386 (NUMFST n) (NUMSND n)).
Proof. exact (eq_refl (@INJF A)). Qed.
Definition INJP {A : Type'} : (nat -> A -> Prop) -> (nat -> A -> Prop) -> nat -> A -> Prop := fun _17391 : nat -> A -> Prop => fun _17392 : nat -> A -> Prop => fun n : nat => fun a : A => @COND Prop (NUMLEFT n) (_17391 (NUMRIGHT n) a) (_17392 (NUMRIGHT n) a).
Lemma INJP_def {A : Type'} : (@INJP A) = (fun _17391 : nat -> A -> Prop => fun _17392 : nat -> A -> Prop => fun n : nat => fun a : A => @COND Prop (NUMLEFT n) (_17391 (NUMRIGHT n) a) (_17392 (NUMRIGHT n) a)).
Proof. exact (eq_refl (@INJP A)). Qed.
Definition ZCONSTR {A : Type'} : nat -> A -> (nat -> nat -> A -> Prop) -> nat -> A -> Prop := fun _17403 : nat => fun _17404 : A => fun _17405 : nat -> nat -> A -> Prop => @INJP A (@INJN A (S _17403)) (@INJP A (@INJA A _17404) (@INJF A _17405)).
Lemma ZCONSTR_def {A : Type'} : (@ZCONSTR A) = (fun _17403 : nat => fun _17404 : A => fun _17405 : nat -> nat -> A -> Prop => @INJP A (@INJN A (S _17403)) (@INJP A (@INJA A _17404) (@INJF A _17405))).
Proof. exact (eq_refl (@ZCONSTR A)). Qed.
Definition ZBOT {A : Type'} : nat -> A -> Prop := @INJP A (@INJN A (NUMERAL 0)) (@ε (nat -> A -> Prop) (fun z : nat -> A -> Prop => True)).
Lemma ZBOT_def {A : Type'} : (@ZBOT A) = (@INJP A (@INJN A (NUMERAL 0)) (@ε (nat -> A -> Prop) (fun z : nat -> A -> Prop => True))).
Proof. exact (eq_refl (@ZBOT A)). Qed.
Definition BOTTOM {A : Type'} : recspace A := @_mk_rec A (@ZBOT A).
Lemma BOTTOM_def {A : Type'} : (@BOTTOM A) = (@_mk_rec A (@ZBOT A)).
Proof. exact (eq_refl (@BOTTOM A)). Qed.
Definition CONSTR {A : Type'} : nat -> A -> (nat -> recspace A) -> recspace A := fun _17428 : nat => fun _17429 : A => fun _17430 : nat -> recspace A => @_mk_rec A (@ZCONSTR A _17428 _17429 (fun n : nat => @_dest_rec A (_17430 n))).
Lemma CONSTR_def {A : Type'} : (@CONSTR A) = (fun _17428 : nat => fun _17429 : A => fun _17430 : nat -> recspace A => @_mk_rec A (@ZCONSTR A _17428 _17429 (fun n : nat => @_dest_rec A (_17430 n)))).
Proof. exact (eq_refl (@CONSTR A)). Qed.
Definition FNIL {A : Type'} : nat -> A := fun _17461 : nat => @ε A (fun x : A => True).
Lemma FNIL_def {A : Type'} : (@FNIL A) = (fun _17461 : nat => @ε A (fun x : A => True)).
Proof. exact (eq_refl (@FNIL A)). Qed.
Definition OUTL {A B : Type'} : (Datatypes.sum A B) -> A := @ε ((prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> A) (fun OUTL' : (prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> A => forall _17486 : prod nat (prod nat (prod nat nat)), forall x : A, (OUTL' _17486 (@inl A B x)) = x) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0))))))))))).
Lemma OUTL_def {A B : Type'} : (@OUTL A B) = (@ε ((prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> A) (fun OUTL' : (prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> A => forall _17486 : prod nat (prod nat (prod nat nat)), forall x : A, (OUTL' _17486 (@inl A B x)) = x) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))))))).
Proof. exact (eq_refl (@OUTL A B)). Qed.
Definition OUTR {A B : Type'} : (Datatypes.sum A B) -> B := @ε ((prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> B) (fun OUTR' : (prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> B => forall _17488 : prod nat (prod nat (prod nat nat)), forall y : B, (OUTR' _17488 (@inr A B y)) = y) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0))))))))))).
Lemma OUTR_def {A B : Type'} : (@OUTR A B) = (@ε ((prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> B) (fun OUTR' : (prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> B => forall _17488 : prod nat (prod nat (prod nat nat)), forall y : B, (OUTR' _17488 (@inr A B y)) = y) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))))))).
Proof. exact (eq_refl (@OUTR A B)). Qed.
Definition LAST {A : Type'} : (list A) -> A := @ε ((prod nat (prod nat (prod nat nat))) -> (list A) -> A) (fun LAST' : (prod nat (prod nat (prod nat nat))) -> (list A) -> A => forall _17954 : prod nat (prod nat (prod nat nat)), forall h : A, forall t : list A, (LAST' _17954 (@cons A h t)) = (@COND A (t = (@nil A)) h (LAST' _17954 t))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0))))))))))).
Lemma LAST_def {A : Type'} : (@LAST A) = (@ε ((prod nat (prod nat (prod nat nat))) -> (list A) -> A) (fun LAST' : (prod nat (prod nat (prod nat nat))) -> (list A) -> A => forall _17954 : prod nat (prod nat (prod nat nat)), forall h : A, forall t : list A, (LAST' _17954 (@cons A h t)) = (@COND A (t = (@nil A)) h (LAST' _17954 t))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))))))).
Proof. exact (eq_refl (@LAST A)). Qed.
Definition NULL {_25287 : Type'} : (list _25287) -> Prop := @ε ((prod nat (prod nat (prod nat nat))) -> (list _25287) -> Prop) (fun NULL' : (prod nat (prod nat (prod nat nat))) -> (list _25287) -> Prop => forall _17966 : prod nat (prod nat (prod nat nat)), ((NULL' _17966 (@nil _25287)) = True) /\ (forall h : _25287, forall t : list _25287, (NULL' _17966 (@cons _25287 h t)) = False)) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0))))))))))).
Lemma NULL_def {_25287 : Type'} : (@NULL _25287) = (@ε ((prod nat (prod nat (prod nat nat))) -> (list _25287) -> Prop) (fun NULL' : (prod nat (prod nat (prod nat nat))) -> (list _25287) -> Prop => forall _17966 : prod nat (prod nat (prod nat nat)), ((NULL' _17966 (@nil _25287)) = True) /\ (forall h : _25287, forall t : list _25287, (NULL' _17966 (@cons _25287 h t)) = False)) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))))))).
Proof. exact (eq_refl (@NULL _25287)). Qed.
Definition EX {_25328 : Type'} : (_25328 -> Prop) -> (list _25328) -> Prop := @ε ((prod nat nat) -> (_25328 -> Prop) -> (list _25328) -> Prop) (fun EX' : (prod nat nat) -> (_25328 -> Prop) -> (list _25328) -> Prop => forall _17980 : prod nat nat, (forall P : _25328 -> Prop, (EX' _17980 P (@nil _25328)) = False) /\ (forall h : _25328, forall P : _25328 -> Prop, forall t : list _25328, (EX' _17980 P (@cons _25328 h t)) = ((P h) \/ (EX' _17980 P t)))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 0))))))))).
Lemma EX_def {_25328 : Type'} : (@EX _25328) = (@ε ((prod nat nat) -> (_25328 -> Prop) -> (list _25328) -> Prop) (fun EX' : (prod nat nat) -> (_25328 -> Prop) -> (list _25328) -> Prop => forall _17980 : prod nat nat, (forall P : _25328 -> Prop, (EX' _17980 P (@nil _25328)) = False) /\ (forall h : _25328, forall P : _25328 -> Prop, forall t : list _25328, (EX' _17980 P (@cons _25328 h t)) = ((P h) \/ (EX' _17980 P t)))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 0)))))))))).
Proof. exact (eq_refl (@EX _25328)). Qed.
Definition ITLIST {_25350 _25351 : Type'} : (_25351 -> _25350 -> _25350) -> (list _25351) -> _25350 -> _25350 := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (_25351 -> _25350 -> _25350) -> (list _25351) -> _25350 -> _25350) (fun ITLIST' : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (_25351 -> _25350 -> _25350) -> (list _25351) -> _25350 -> _25350 => forall _17988 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), (forall f : _25351 -> _25350 -> _25350, forall b : _25350, (ITLIST' _17988 f (@nil _25351) b) = b) /\ (forall h : _25351, forall f : _25351 -> _25350 -> _25350, forall t : list _25351, forall b : _25350, (ITLIST' _17988 f (@cons _25351 h t) b) = (f h (ITLIST' _17988 f t b)))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0))))))))))))).
Lemma ITLIST_def {_25350 _25351 : Type'} : (@ITLIST _25350 _25351) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (_25351 -> _25350 -> _25350) -> (list _25351) -> _25350 -> _25350) (fun ITLIST' : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (_25351 -> _25350 -> _25350) -> (list _25351) -> _25350 -> _25350 => forall _17988 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), (forall f : _25351 -> _25350 -> _25350, forall b : _25350, (ITLIST' _17988 f (@nil _25351) b) = b) /\ (forall h : _25351, forall f : _25351 -> _25350 -> _25350, forall t : list _25351, forall b : _25350, (ITLIST' _17988 f (@cons _25351 h t) b) = (f h (ITLIST' _17988 f t b)))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))))))))).
Proof. exact (eq_refl (@ITLIST _25350 _25351)). Qed.
Definition ALL2 {_25409 _25416 : Type'} : (_25409 -> _25416 -> Prop) -> (list _25409) -> (list _25416) -> Prop := @ε ((prod nat (prod nat (prod nat nat))) -> (_25409 -> _25416 -> Prop) -> (list _25409) -> (list _25416) -> Prop) (fun ALL2' : (prod nat (prod nat (prod nat nat))) -> (_25409 -> _25416 -> Prop) -> (list _25409) -> (list _25416) -> Prop => forall _18003 : prod nat (prod nat (prod nat nat)), (forall P : _25409 -> _25416 -> Prop, forall l2 : list _25416, (ALL2' _18003 P (@nil _25409) l2) = (l2 = (@nil _25416))) /\ (forall h1' : _25409, forall P : _25409 -> _25416 -> Prop, forall t1 : list _25409, forall l2 : list _25416, (ALL2' _18003 P (@cons _25409 h1' t1) l2) = (@COND Prop (l2 = (@nil _25416)) False ((P h1' (@hd _25416 l2)) /\ (ALL2' _18003 P t1 (@tl _25416 l2)))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))))).
Lemma ALL2_def {_25409 _25416 : Type'} : (@ALL2 _25409 _25416) = (@ε ((prod nat (prod nat (prod nat nat))) -> (_25409 -> _25416 -> Prop) -> (list _25409) -> (list _25416) -> Prop) (fun ALL2' : (prod nat (prod nat (prod nat nat))) -> (_25409 -> _25416 -> Prop) -> (list _25409) -> (list _25416) -> Prop => forall _18003 : prod nat (prod nat (prod nat nat)), (forall P : _25409 -> _25416 -> Prop, forall l2 : list _25416, (ALL2' _18003 P (@nil _25409) l2) = (l2 = (@nil _25416))) /\ (forall h1' : _25409, forall P : _25409 -> _25416 -> Prop, forall t1 : list _25409, forall l2 : list _25416, (ALL2' _18003 P (@cons _25409 h1' t1) l2) = (@COND Prop (l2 = (@nil _25416)) False ((P h1' (@hd _25416 l2)) /\ (ALL2' _18003 P t1 (@tl _25416 l2)))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0))))))))))).
Proof. exact (eq_refl (@ALL2 _25409 _25416)). Qed.
Definition MAP2 {_25498 _25501 _25508 : Type'} : (_25501 -> _25508 -> _25498) -> (list _25501) -> (list _25508) -> list _25498 := @ε ((prod nat (prod nat (prod nat nat))) -> (_25501 -> _25508 -> _25498) -> (list _25501) -> (list _25508) -> list _25498) (fun MAP2' : (prod nat (prod nat (prod nat nat))) -> (_25501 -> _25508 -> _25498) -> (list _25501) -> (list _25508) -> list _25498 => forall _18011 : prod nat (prod nat (prod nat nat)), (forall f : _25501 -> _25508 -> _25498, forall l : list _25508, (MAP2' _18011 f (@nil _25501) l) = (@nil _25498)) /\ (forall h1' : _25501, forall f : _25501 -> _25508 -> _25498, forall t1 : list _25501, forall l : list _25508, (MAP2' _18011 f (@cons _25501 h1' t1) l) = (@cons _25498 (f h1' (@hd _25508 l)) (MAP2' _18011 f t1 (@tl _25508 l))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))))).
Lemma MAP2_def {_25498 _25501 _25508 : Type'} : (@MAP2 _25498 _25501 _25508) = (@ε ((prod nat (prod nat (prod nat nat))) -> (_25501 -> _25508 -> _25498) -> (list _25501) -> (list _25508) -> list _25498) (fun MAP2' : (prod nat (prod nat (prod nat nat))) -> (_25501 -> _25508 -> _25498) -> (list _25501) -> (list _25508) -> list _25498 => forall _18011 : prod nat (prod nat (prod nat nat)), (forall f : _25501 -> _25508 -> _25498, forall l : list _25508, (MAP2' _18011 f (@nil _25501) l) = (@nil _25498)) /\ (forall h1' : _25501, forall f : _25501 -> _25508 -> _25498, forall t1 : list _25501, forall l : list _25508, (MAP2' _18011 f (@cons _25501 h1' t1) l) = (@cons _25498 (f h1' (@hd _25508 l)) (MAP2' _18011 f t1 (@tl _25508 l))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0))))))))))).
Proof. exact (eq_refl (@MAP2 _25498 _25501 _25508)). Qed.
Definition EL {_25569 : Type'} : nat -> (list _25569) -> _25569 := @ε ((prod nat nat) -> nat -> (list _25569) -> _25569) (fun EL' : (prod nat nat) -> nat -> (list _25569) -> _25569 => forall _18015 : prod nat nat, (forall l : list _25569, (EL' _18015 (NUMERAL 0) l) = (@hd _25569 l)) /\ (forall n : nat, forall l : list _25569, (EL' _18015 (S n) l) = (EL' _18015 n (@tl _25569 l)))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0))))))))).
Lemma EL_def {_25569 : Type'} : (@EL _25569) = (@ε ((prod nat nat) -> nat -> (list _25569) -> _25569) (fun EL' : (prod nat nat) -> nat -> (list _25569) -> _25569 => forall _18015 : prod nat nat, (forall l : list _25569, (EL' _18015 (NUMERAL 0) l) = (@hd _25569 l)) /\ (forall n : nat, forall l : list _25569, (EL' _18015 (S n) l) = (EL' _18015 n (@tl _25569 l)))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))))).
Proof. exact (eq_refl (@EL _25569)). Qed.
Definition FILTER {_25594 : Type'} : (_25594 -> Prop) -> (list _25594) -> list _25594 := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (_25594 -> Prop) -> (list _25594) -> list _25594) (fun FILTER' : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (_25594 -> Prop) -> (list _25594) -> list _25594 => forall _18022 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), (forall P : _25594 -> Prop, (FILTER' _18022 P (@nil _25594)) = (@nil _25594)) /\ (forall h : _25594, forall P : _25594 -> Prop, forall t : list _25594, (FILTER' _18022 P (@cons _25594 h t)) = (@COND (list _25594) (P h) (@cons _25594 h (FILTER' _18022 P t)) (FILTER' _18022 P t)))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0))))))))))))).
Lemma FILTER_def {_25594 : Type'} : (@FILTER _25594) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (_25594 -> Prop) -> (list _25594) -> list _25594) (fun FILTER' : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (_25594 -> Prop) -> (list _25594) -> list _25594 => forall _18022 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), (forall P : _25594 -> Prop, (FILTER' _18022 P (@nil _25594)) = (@nil _25594)) /\ (forall h : _25594, forall P : _25594 -> Prop, forall t : list _25594, (FILTER' _18022 P (@cons _25594 h t)) = (@COND (list _25594) (P h) (@cons _25594 h (FILTER' _18022 P t)) (FILTER' _18022 P t)))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))))))))).
Proof. exact (eq_refl (@FILTER _25594)). Qed.
Definition ASSOC {_25617 _25623 : Type'} : _25623 -> (list (prod _25623 _25617)) -> _25617 := @ε ((prod nat (prod nat (prod nat (prod nat nat)))) -> _25623 -> (list (prod _25623 _25617)) -> _25617) (fun ASSOC' : (prod nat (prod nat (prod nat (prod nat nat)))) -> _25623 -> (list (prod _25623 _25617)) -> _25617 => forall _18029 : prod nat (prod nat (prod nat (prod nat nat))), forall h : prod _25623 _25617, forall a : _25623, forall t : list (prod _25623 _25617), (ASSOC' _18029 a (@cons (prod _25623 _25617) h t)) = (@COND _25617 ((@fst _25623 _25617 h) = a) (@snd _25623 _25617 h) (ASSOC' _18029 a t))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))))))).
Lemma ASSOC_def {_25617 _25623 : Type'} : (@ASSOC _25617 _25623) = (@ε ((prod nat (prod nat (prod nat (prod nat nat)))) -> _25623 -> (list (prod _25623 _25617)) -> _25617) (fun ASSOC' : (prod nat (prod nat (prod nat (prod nat nat)))) -> _25623 -> (list (prod _25623 _25617)) -> _25617 => forall _18029 : prod nat (prod nat (prod nat (prod nat nat))), forall h : prod _25623 _25617, forall a : _25623, forall t : list (prod _25623 _25617), (ASSOC' _18029 a (@cons (prod _25623 _25617) h t)) = (@COND _25617 ((@fst _25623 _25617 h) = a) (@snd _25623 _25617 h) (ASSOC' _18029 a t))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0))))))))))))).
Proof. exact (eq_refl (@ASSOC _25617 _25623)). Qed.
Definition ITLIST2 {_25645 _25647 _25655 : Type'} : (_25647 -> _25655 -> _25645 -> _25645) -> (list _25647) -> (list _25655) -> _25645 -> _25645 := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (_25647 -> _25655 -> _25645 -> _25645) -> (list _25647) -> (list _25655) -> _25645 -> _25645) (fun ITLIST2' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (_25647 -> _25655 -> _25645 -> _25645) -> (list _25647) -> (list _25655) -> _25645 -> _25645 => forall _18038 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))), (forall f : _25647 -> _25655 -> _25645 -> _25645, forall l2 : list _25655, forall b : _25645, (ITLIST2' _18038 f (@nil _25647) l2 b) = b) /\ (forall h1' : _25647, forall f : _25647 -> _25655 -> _25645 -> _25645, forall t1 : list _25647, forall l2 : list _25655, forall b : _25645, (ITLIST2' _18038 f (@cons _25647 h1' t1) l2 b) = (f h1' (@hd _25655 l2) (ITLIST2' _18038 f t1 (@tl _25655 l2) b)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0))))))))))))).
Lemma ITLIST2_def {_25645 _25647 _25655 : Type'} : (@ITLIST2 _25645 _25647 _25655) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (_25647 -> _25655 -> _25645 -> _25645) -> (list _25647) -> (list _25655) -> _25645 -> _25645) (fun ITLIST2' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (_25647 -> _25655 -> _25645 -> _25645) -> (list _25647) -> (list _25655) -> _25645 -> _25645 => forall _18038 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))), (forall f : _25647 -> _25655 -> _25645 -> _25645, forall l2 : list _25655, forall b : _25645, (ITLIST2' _18038 f (@nil _25647) l2 b) = b) /\ (forall h1' : _25647, forall f : _25647 -> _25655 -> _25645 -> _25645, forall t1 : list _25647, forall l2 : list _25655, forall b : _25645, (ITLIST2' _18038 f (@cons _25647 h1' t1) l2 b) = (f h1' (@hd _25655 l2) (ITLIST2' _18038 f t1 (@tl _25655 l2) b)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))))))))).
Proof. exact (eq_refl (@ITLIST2 _25645 _25647 _25655)). Qed.
Definition ZIP {_25719 _25727 : Type'} : (list _25719) -> (list _25727) -> list (prod _25719 _25727) := @ε ((prod nat (prod nat nat)) -> (list _25719) -> (list _25727) -> list (prod _25719 _25727)) (fun ZIP' : (prod nat (prod nat nat)) -> (list _25719) -> (list _25727) -> list (prod _25719 _25727) => forall _18042 : prod nat (prod nat nat), (forall l2 : list _25727, (ZIP' _18042 (@nil _25719) l2) = (@nil (prod _25719 _25727))) /\ (forall h1' : _25719, forall t1 : list _25719, forall l2 : list _25727, (ZIP' _18042 (@cons _25719 h1' t1) l2) = (@cons (prod _25719 _25727) (@pair _25719 _25727 h1' (@hd _25727 l2)) (ZIP' _18042 t1 (@tl _25727 l2))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))))).
Lemma ZIP_def {_25719 _25727 : Type'} : (@ZIP _25719 _25727) = (@ε ((prod nat (prod nat nat)) -> (list _25719) -> (list _25727) -> list (prod _25719 _25727)) (fun ZIP' : (prod nat (prod nat nat)) -> (list _25719) -> (list _25727) -> list (prod _25719 _25727) => forall _18042 : prod nat (prod nat nat), (forall l2 : list _25727, (ZIP' _18042 (@nil _25719) l2) = (@nil (prod _25719 _25727))) /\ (forall h1' : _25719, forall t1 : list _25719, forall l2 : list _25727, (ZIP' _18042 (@cons _25719 h1' t1) l2) = (@cons (prod _25719 _25727) (@pair _25719 _25727 h1' (@hd _25727 l2)) (ZIP' _18042 t1 (@tl _25727 l2))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0))))))))))).
Proof. exact (eq_refl (@ZIP _25719 _25727)). Qed.
Definition ALLPAIRS {_25786 _25787 : Type'} : (_25787 -> _25786 -> Prop) -> (list _25787) -> (list _25786) -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (_25787 -> _25786 -> Prop) -> (list _25787) -> (list _25786) -> Prop) (fun ALLPAIRS' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (_25787 -> _25786 -> Prop) -> (list _25787) -> (list _25786) -> Prop => forall _18050 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))), (forall f : _25787 -> _25786 -> Prop, forall l : list _25786, (ALLPAIRS' _18050 f (@nil _25787) l) = True) /\ (forall h : _25787, forall f : _25787 -> _25786 -> Prop, forall t : list _25787, forall l : list _25786, (ALLPAIRS' _18050 f (@cons _25787 h t) l) = ((@List.Forall _25786 (f h) l) /\ (ALLPAIRS' _18050 f t l)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0))))))))))))))).
Lemma ALLPAIRS_def {_25786 _25787 : Type'} : (@ALLPAIRS _25786 _25787) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (_25787 -> _25786 -> Prop) -> (list _25787) -> (list _25786) -> Prop) (fun ALLPAIRS' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (_25787 -> _25786 -> Prop) -> (list _25787) -> (list _25786) -> Prop => forall _18050 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))), (forall f : _25787 -> _25786 -> Prop, forall l : list _25786, (ALLPAIRS' _18050 f (@nil _25787) l) = True) /\ (forall h : _25787, forall f : _25787 -> _25786 -> Prop, forall t : list _25787, forall l : list _25786, (ALLPAIRS' _18050 f (@cons _25787 h t) l) = ((@List.Forall _25786 (f h) l) /\ (ALLPAIRS' _18050 f t l)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))))))))))).
Proof. exact (eq_refl (@ALLPAIRS _25786 _25787)). Qed.
Definition list_of_seq {A : Type'} : (nat -> A) -> nat -> list A := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (nat -> A) -> nat -> list A) (fun list_of_seq' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (nat -> A) -> nat -> list A => forall _18064 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))), (forall s : nat -> A, (list_of_seq' _18064 s (NUMERAL 0)) = (@nil A)) /\ (forall s : nat -> A, forall n : nat, (list_of_seq' _18064 s (S n)) = (@List.app A (list_of_seq' _18064 s n) (@cons A (s n) (@nil A))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))))))))))))).
Lemma list_of_seq_def {A : Type'} : (@list_of_seq A) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (nat -> A) -> nat -> list A) (fun list_of_seq' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (nat -> A) -> nat -> list A => forall _18064 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))), (forall s : nat -> A, (list_of_seq' _18064 s (NUMERAL 0)) = (@nil A)) /\ (forall s : nat -> A, forall n : nat, (list_of_seq' _18064 s (S n)) = (@List.app A (list_of_seq' _18064 s n) (@cons A (s n) (@nil A))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0))))))))))))))))))).
Proof. exact (eq_refl (@list_of_seq A)). Qed.
Definition _22730 : Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Ascii.ascii := fun a0 : Prop => fun a1 : Prop => fun a2 : Prop => fun a3 : Prop => fun a4 : Prop => fun a5 : Prop => fun a6 : Prop => fun a7 : Prop => _mk_char ((fun a0' : Prop => fun a1' : Prop => fun a2' : Prop => fun a3' : Prop => fun a4' : Prop => fun a5' : Prop => fun a6' : Prop => fun a7' : Prop => @CONSTR (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))) (NUMERAL 0) (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))))) a0' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))) a1' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))) a2' (@pair Prop (prod Prop (prod Prop (prod Prop Prop))) a3' (@pair Prop (prod Prop (prod Prop Prop)) a4' (@pair Prop (prod Prop Prop) a5' (@pair Prop Prop a6' a7'))))))) (fun n : nat => @BOTTOM (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))))) a0 a1 a2 a3 a4 a5 a6 a7).
Lemma _22730_def : _22730 = (fun a0 : Prop => fun a1 : Prop => fun a2 : Prop => fun a3 : Prop => fun a4 : Prop => fun a5 : Prop => fun a6 : Prop => fun a7 : Prop => _mk_char ((fun a0' : Prop => fun a1' : Prop => fun a2' : Prop => fun a3' : Prop => fun a4' : Prop => fun a5' : Prop => fun a6' : Prop => fun a7' : Prop => @CONSTR (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))) (NUMERAL 0) (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))))) a0' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))) a1' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))) a2' (@pair Prop (prod Prop (prod Prop (prod Prop Prop))) a3' (@pair Prop (prod Prop (prod Prop Prop)) a4' (@pair Prop (prod Prop Prop) a5' (@pair Prop Prop a6' a7'))))))) (fun n : nat => @BOTTOM (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))))) a0 a1 a2 a3 a4 a5 a6 a7)).
Proof. exact (eq_refl _22730). Qed.
Definition ASCII : Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Ascii.ascii := _22730.
Lemma ASCII_def : ASCII = _22730.
Proof. exact (eq_refl ASCII). Qed.
Definition dist : (prod nat nat) -> nat := fun _22820 : prod nat nat => Nat.add (Nat.sub (@fst nat nat _22820) (@snd nat nat _22820)) (Nat.sub (@snd nat nat _22820) (@fst nat nat _22820)).
Lemma dist_def : dist = (fun _22820 : prod nat nat => Nat.add (Nat.sub (@fst nat nat _22820) (@snd nat nat _22820)) (Nat.sub (@snd nat nat _22820) (@fst nat nat _22820))).
Proof. exact (eq_refl dist). Qed.
Definition is_nadd : (nat -> nat) -> Prop := fun _23130 : nat -> nat => exists B : nat, forall m : nat, forall n : nat, Peano.le (dist (@pair nat nat (Nat.mul m (_23130 n)) (Nat.mul n (_23130 m)))) (Nat.mul B (Nat.add m n)).
Lemma is_nadd_def : is_nadd = (fun _23130 : nat -> nat => exists B : nat, forall m : nat, forall n : nat, Peano.le (dist (@pair nat nat (Nat.mul m (_23130 n)) (Nat.mul n (_23130 m)))) (Nat.mul B (Nat.add m n))).
Proof. exact (eq_refl is_nadd). Qed.
Definition nadd_eq : nadd -> nadd -> Prop := fun _23149 : nadd => fun _23150 : nadd => exists B : nat, forall n : nat, Peano.le (dist (@pair nat nat (dest_nadd _23149 n) (dest_nadd _23150 n))) B.
Lemma nadd_eq_def : nadd_eq = (fun _23149 : nadd => fun _23150 : nadd => exists B : nat, forall n : nat, Peano.le (dist (@pair nat nat (dest_nadd _23149 n) (dest_nadd _23150 n))) B).
Proof. exact (eq_refl nadd_eq). Qed.
Definition nadd_of_num : nat -> nadd := fun _23161 : nat => mk_nadd (fun n : nat => Nat.mul _23161 n).
Lemma nadd_of_num_def : nadd_of_num = (fun _23161 : nat => mk_nadd (fun n : nat => Nat.mul _23161 n)).
Proof. exact (eq_refl nadd_of_num). Qed.
Definition nadd_le : nadd -> nadd -> Prop := fun _23168 : nadd => fun _23169 : nadd => exists B : nat, forall n : nat, Peano.le (dest_nadd _23168 n) (Nat.add (dest_nadd _23169 n) B).
Lemma nadd_le_def : nadd_le = (fun _23168 : nadd => fun _23169 : nadd => exists B : nat, forall n : nat, Peano.le (dest_nadd _23168 n) (Nat.add (dest_nadd _23169 n) B)).
Proof. exact (eq_refl nadd_le). Qed.
Definition nadd_add : nadd -> nadd -> nadd := fun _23184 : nadd => fun _23185 : nadd => mk_nadd (fun n : nat => Nat.add (dest_nadd _23184 n) (dest_nadd _23185 n)).
Lemma nadd_add_def : nadd_add = (fun _23184 : nadd => fun _23185 : nadd => mk_nadd (fun n : nat => Nat.add (dest_nadd _23184 n) (dest_nadd _23185 n))).
Proof. exact (eq_refl nadd_add). Qed.
Definition nadd_mul : nadd -> nadd -> nadd := fun _23198 : nadd => fun _23199 : nadd => mk_nadd (fun n : nat => dest_nadd _23198 (dest_nadd _23199 n)).
Lemma nadd_mul_def : nadd_mul = (fun _23198 : nadd => fun _23199 : nadd => mk_nadd (fun n : nat => dest_nadd _23198 (dest_nadd _23199 n))).
Proof. exact (eq_refl nadd_mul). Qed.
Definition nadd_rinv : nadd -> nat -> nat := fun _23335 : nadd => fun n : nat => Nat.div (Nat.mul n n) (dest_nadd _23335 n).
Lemma nadd_rinv_def : nadd_rinv = (fun _23335 : nadd => fun n : nat => Nat.div (Nat.mul n n) (dest_nadd _23335 n)).
Proof. exact (eq_refl nadd_rinv). Qed.
Definition nadd_inv : nadd -> nadd := fun _23349 : nadd => @COND nadd (nadd_eq _23349 (nadd_of_num (NUMERAL 0))) (nadd_of_num (NUMERAL 0)) (mk_nadd (nadd_rinv _23349)).
Lemma nadd_inv_def : nadd_inv = (fun _23349 : nadd => @COND nadd (nadd_eq _23349 (nadd_of_num (NUMERAL 0))) (nadd_of_num (NUMERAL 0)) (mk_nadd (nadd_rinv _23349))).
Proof. exact (eq_refl nadd_inv). Qed.
Axiom mk_hreal : (nadd -> Prop) -> hreal.
Axiom dest_hreal : hreal -> nadd -> Prop.
Definition hreal_of_num : nat -> hreal := fun m : nat => mk_hreal (fun u : nadd => nadd_eq (nadd_of_num m) u).
Lemma hreal_of_num_def : hreal_of_num = (fun m : nat => mk_hreal (fun u : nadd => nadd_eq (nadd_of_num m) u)).
Proof. exact (eq_refl hreal_of_num). Qed.
Definition hreal_add : hreal -> hreal -> hreal := fun x : hreal => fun y : hreal => mk_hreal (fun u : nadd => exists x' : nadd, exists y' : nadd, (nadd_eq (nadd_add x' y') u) /\ ((dest_hreal x x') /\ (dest_hreal y y'))).
Lemma hreal_add_def : hreal_add = (fun x : hreal => fun y : hreal => mk_hreal (fun u : nadd => exists x' : nadd, exists y' : nadd, (nadd_eq (nadd_add x' y') u) /\ ((dest_hreal x x') /\ (dest_hreal y y')))).
Proof. exact (eq_refl hreal_add). Qed.
Definition hreal_mul : hreal -> hreal -> hreal := fun x : hreal => fun y : hreal => mk_hreal (fun u : nadd => exists x' : nadd, exists y' : nadd, (nadd_eq (nadd_mul x' y') u) /\ ((dest_hreal x x') /\ (dest_hreal y y'))).
Lemma hreal_mul_def : hreal_mul = (fun x : hreal => fun y : hreal => mk_hreal (fun u : nadd => exists x' : nadd, exists y' : nadd, (nadd_eq (nadd_mul x' y') u) /\ ((dest_hreal x x') /\ (dest_hreal y y')))).
Proof. exact (eq_refl hreal_mul). Qed.
Definition hreal_le : hreal -> hreal -> Prop := fun x : hreal => fun y : hreal => @ε Prop (fun u : Prop => exists x' : nadd, exists y' : nadd, ((nadd_le x' y') = u) /\ ((dest_hreal x x') /\ (dest_hreal y y'))).
Lemma hreal_le_def : hreal_le = (fun x : hreal => fun y : hreal => @ε Prop (fun u : Prop => exists x' : nadd, exists y' : nadd, ((nadd_le x' y') = u) /\ ((dest_hreal x x') /\ (dest_hreal y y')))).
Proof. exact (eq_refl hreal_le). Qed.
Definition hreal_inv : hreal -> hreal := fun x : hreal => mk_hreal (fun u : nadd => exists x' : nadd, (nadd_eq (nadd_inv x') u) /\ (dest_hreal x x')).
Lemma hreal_inv_def : hreal_inv = (fun x : hreal => mk_hreal (fun u : nadd => exists x' : nadd, (nadd_eq (nadd_inv x') u) /\ (dest_hreal x x'))).
Proof. exact (eq_refl hreal_inv). Qed.
Definition treal_of_num : nat -> prod hreal hreal := fun _23594 : nat => @pair hreal hreal (hreal_of_num _23594) (hreal_of_num (NUMERAL 0)).
Lemma treal_of_num_def : treal_of_num = (fun _23594 : nat => @pair hreal hreal (hreal_of_num _23594) (hreal_of_num (NUMERAL 0))).
Proof. exact (eq_refl treal_of_num). Qed.
Definition treal_neg : (prod hreal hreal) -> prod hreal hreal := fun _23599 : prod hreal hreal => @pair hreal hreal (@snd hreal hreal _23599) (@fst hreal hreal _23599).
Lemma treal_neg_def : treal_neg = (fun _23599 : prod hreal hreal => @pair hreal hreal (@snd hreal hreal _23599) (@fst hreal hreal _23599)).
Proof. exact (eq_refl treal_neg). Qed.
Definition treal_add : (prod hreal hreal) -> (prod hreal hreal) -> prod hreal hreal := fun _23608 : prod hreal hreal => fun _23609 : prod hreal hreal => @pair hreal hreal (hreal_add (@fst hreal hreal _23608) (@fst hreal hreal _23609)) (hreal_add (@snd hreal hreal _23608) (@snd hreal hreal _23609)).
Lemma treal_add_def : treal_add = (fun _23608 : prod hreal hreal => fun _23609 : prod hreal hreal => @pair hreal hreal (hreal_add (@fst hreal hreal _23608) (@fst hreal hreal _23609)) (hreal_add (@snd hreal hreal _23608) (@snd hreal hreal _23609))).
Proof. exact (eq_refl treal_add). Qed.
Definition treal_mul : (prod hreal hreal) -> (prod hreal hreal) -> prod hreal hreal := fun _23630 : prod hreal hreal => fun _23631 : prod hreal hreal => @pair hreal hreal (hreal_add (hreal_mul (@fst hreal hreal _23630) (@fst hreal hreal _23631)) (hreal_mul (@snd hreal hreal _23630) (@snd hreal hreal _23631))) (hreal_add (hreal_mul (@fst hreal hreal _23630) (@snd hreal hreal _23631)) (hreal_mul (@snd hreal hreal _23630) (@fst hreal hreal _23631))).
Lemma treal_mul_def : treal_mul = (fun _23630 : prod hreal hreal => fun _23631 : prod hreal hreal => @pair hreal hreal (hreal_add (hreal_mul (@fst hreal hreal _23630) (@fst hreal hreal _23631)) (hreal_mul (@snd hreal hreal _23630) (@snd hreal hreal _23631))) (hreal_add (hreal_mul (@fst hreal hreal _23630) (@snd hreal hreal _23631)) (hreal_mul (@snd hreal hreal _23630) (@fst hreal hreal _23631)))).
Proof. exact (eq_refl treal_mul). Qed.
Definition treal_le : (prod hreal hreal) -> (prod hreal hreal) -> Prop := fun _23652 : prod hreal hreal => fun _23653 : prod hreal hreal => hreal_le (hreal_add (@fst hreal hreal _23652) (@snd hreal hreal _23653)) (hreal_add (@fst hreal hreal _23653) (@snd hreal hreal _23652)).
Lemma treal_le_def : treal_le = (fun _23652 : prod hreal hreal => fun _23653 : prod hreal hreal => hreal_le (hreal_add (@fst hreal hreal _23652) (@snd hreal hreal _23653)) (hreal_add (@fst hreal hreal _23653) (@snd hreal hreal _23652))).
Proof. exact (eq_refl treal_le). Qed.
Definition treal_inv : (prod hreal hreal) -> prod hreal hreal := fun _23674 : prod hreal hreal => @COND (prod hreal hreal) ((@fst hreal hreal _23674) = (@snd hreal hreal _23674)) (@pair hreal hreal (hreal_of_num (NUMERAL 0)) (hreal_of_num (NUMERAL 0))) (@COND (prod hreal hreal) (hreal_le (@snd hreal hreal _23674) (@fst hreal hreal _23674)) (@pair hreal hreal (hreal_inv (@ε hreal (fun d : hreal => (@fst hreal hreal _23674) = (hreal_add (@snd hreal hreal _23674) d)))) (hreal_of_num (NUMERAL 0))) (@pair hreal hreal (hreal_of_num (NUMERAL 0)) (hreal_inv (@ε hreal (fun d : hreal => (@snd hreal hreal _23674) = (hreal_add (@fst hreal hreal _23674) d)))))).
Lemma treal_inv_def : treal_inv = (fun _23674 : prod hreal hreal => @COND (prod hreal hreal) ((@fst hreal hreal _23674) = (@snd hreal hreal _23674)) (@pair hreal hreal (hreal_of_num (NUMERAL 0)) (hreal_of_num (NUMERAL 0))) (@COND (prod hreal hreal) (hreal_le (@snd hreal hreal _23674) (@fst hreal hreal _23674)) (@pair hreal hreal (hreal_inv (@ε hreal (fun d : hreal => (@fst hreal hreal _23674) = (hreal_add (@snd hreal hreal _23674) d)))) (hreal_of_num (NUMERAL 0))) (@pair hreal hreal (hreal_of_num (NUMERAL 0)) (hreal_inv (@ε hreal (fun d : hreal => (@snd hreal hreal _23674) = (hreal_add (@fst hreal hreal _23674) d))))))).
Proof. exact (eq_refl treal_inv). Qed.
Definition treal_eq : (prod hreal hreal) -> (prod hreal hreal) -> Prop := fun _23683 : prod hreal hreal => fun _23684 : prod hreal hreal => (hreal_add (@fst hreal hreal _23683) (@snd hreal hreal _23684)) = (hreal_add (@fst hreal hreal _23684) (@snd hreal hreal _23683)).
Lemma treal_eq_def : treal_eq = (fun _23683 : prod hreal hreal => fun _23684 : prod hreal hreal => (hreal_add (@fst hreal hreal _23683) (@snd hreal hreal _23684)) = (hreal_add (@fst hreal hreal _23684) (@snd hreal hreal _23683))).
Proof. exact (eq_refl treal_eq). Qed.
Axiom mk_real : ((prod hreal hreal) -> Prop) -> real.
Axiom dest_real : real -> (prod hreal hreal) -> Prop.
Definition real_of_num : nat -> real := fun m : nat => mk_real (fun u : prod hreal hreal => treal_eq (treal_of_num m) u).
Lemma real_of_num_def : real_of_num = (fun m : nat => mk_real (fun u : prod hreal hreal => treal_eq (treal_of_num m) u)).
Proof. exact (eq_refl real_of_num). Qed.
Definition real_neg : real -> real := fun x1 : real => mk_real (fun u : prod hreal hreal => exists x1' : prod hreal hreal, (treal_eq (treal_neg x1') u) /\ (dest_real x1 x1')).
Lemma real_neg_def : real_neg = (fun x1 : real => mk_real (fun u : prod hreal hreal => exists x1' : prod hreal hreal, (treal_eq (treal_neg x1') u) /\ (dest_real x1 x1'))).
Proof. exact (eq_refl real_neg). Qed.
Definition real_add : real -> real -> real := fun x1 : real => fun y1 : real => mk_real (fun u : prod hreal hreal => exists x1' : prod hreal hreal, exists y1' : prod hreal hreal, (treal_eq (treal_add x1' y1') u) /\ ((dest_real x1 x1') /\ (dest_real y1 y1'))).
Lemma real_add_def : real_add = (fun x1 : real => fun y1 : real => mk_real (fun u : prod hreal hreal => exists x1' : prod hreal hreal, exists y1' : prod hreal hreal, (treal_eq (treal_add x1' y1') u) /\ ((dest_real x1 x1') /\ (dest_real y1 y1')))).
Proof. exact (eq_refl real_add). Qed.
Definition real_mul : real -> real -> real := fun x1 : real => fun y1 : real => mk_real (fun u : prod hreal hreal => exists x1' : prod hreal hreal, exists y1' : prod hreal hreal, (treal_eq (treal_mul x1' y1') u) /\ ((dest_real x1 x1') /\ (dest_real y1 y1'))).
Lemma real_mul_def : real_mul = (fun x1 : real => fun y1 : real => mk_real (fun u : prod hreal hreal => exists x1' : prod hreal hreal, exists y1' : prod hreal hreal, (treal_eq (treal_mul x1' y1') u) /\ ((dest_real x1 x1') /\ (dest_real y1 y1')))).
Proof. exact (eq_refl real_mul). Qed.
Definition real_le : real -> real -> Prop := fun x1 : real => fun y1 : real => @ε Prop (fun u : Prop => exists x1' : prod hreal hreal, exists y1' : prod hreal hreal, ((treal_le x1' y1') = u) /\ ((dest_real x1 x1') /\ (dest_real y1 y1'))).
Lemma real_le_def : real_le = (fun x1 : real => fun y1 : real => @ε Prop (fun u : Prop => exists x1' : prod hreal hreal, exists y1' : prod hreal hreal, ((treal_le x1' y1') = u) /\ ((dest_real x1 x1') /\ (dest_real y1 y1')))).
Proof. exact (eq_refl real_le). Qed.
Definition real_inv : real -> real := fun x : real => mk_real (fun u : prod hreal hreal => exists x' : prod hreal hreal, (treal_eq (treal_inv x') u) /\ (dest_real x x')).
Lemma real_inv_def : real_inv = (fun x : real => mk_real (fun u : prod hreal hreal => exists x' : prod hreal hreal, (treal_eq (treal_inv x') u) /\ (dest_real x x'))).
Proof. exact (eq_refl real_inv). Qed.
Definition real_sub : real -> real -> real := fun _23899 : real => fun _23900 : real => real_add _23899 (real_neg _23900).
Lemma real_sub_def : real_sub = (fun _23899 : real => fun _23900 : real => real_add _23899 (real_neg _23900)).
Proof. exact (eq_refl real_sub). Qed.
Definition real_lt : real -> real -> Prop := fun _23911 : real => fun _23912 : real => ~ (real_le _23912 _23911).
Lemma real_lt_def : real_lt = (fun _23911 : real => fun _23912 : real => ~ (real_le _23912 _23911)).
Proof. exact (eq_refl real_lt). Qed.
Definition real_ge : real -> real -> Prop := fun _23923 : real => fun _23924 : real => real_le _23924 _23923.
Lemma real_ge_def : real_ge = (fun _23923 : real => fun _23924 : real => real_le _23924 _23923).
Proof. exact (eq_refl real_ge). Qed.
Definition real_gt : real -> real -> Prop := fun _23935 : real => fun _23936 : real => real_lt _23936 _23935.
Lemma real_gt_def : real_gt = (fun _23935 : real => fun _23936 : real => real_lt _23936 _23935).
Proof. exact (eq_refl real_gt). Qed.
Definition real_abs : real -> real := fun _23947 : real => @COND real (real_le (real_of_num (NUMERAL 0)) _23947) _23947 (real_neg _23947).
Lemma real_abs_def : real_abs = (fun _23947 : real => @COND real (real_le (real_of_num (NUMERAL 0)) _23947) _23947 (real_neg _23947)).
Proof. exact (eq_refl real_abs). Qed.
Definition real_pow : real -> nat -> real := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> real -> nat -> real) (fun real_pow' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> real -> nat -> real => forall _23958 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))), (forall x : real, (real_pow' _23958 x (NUMERAL 0)) = (real_of_num (NUMERAL (BIT1 0)))) /\ (forall x : real, forall n : nat, (real_pow' _23958 x (S n)) = (real_mul x (real_pow' _23958 x n)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0))))))))))))))).
Lemma real_pow_def : real_pow = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> real -> nat -> real) (fun real_pow' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> real -> nat -> real => forall _23958 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))), (forall x : real, (real_pow' _23958 x (NUMERAL 0)) = (real_of_num (NUMERAL (BIT1 0)))) /\ (forall x : real, forall n : nat, (real_pow' _23958 x (S n)) = (real_mul x (real_pow' _23958 x n)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))))))))))).
Proof. exact (eq_refl real_pow). Qed.
Definition real_div : real -> real -> real := fun _23959 : real => fun _23960 : real => real_mul _23959 (real_inv _23960).
Lemma real_div_def : real_div = (fun _23959 : real => fun _23960 : real => real_mul _23959 (real_inv _23960)).
Proof. exact (eq_refl real_div). Qed.
Definition real_max : real -> real -> real := fun _23971 : real => fun _23972 : real => @COND real (real_le _23971 _23972) _23972 _23971.
Lemma real_max_def : real_max = (fun _23971 : real => fun _23972 : real => @COND real (real_le _23971 _23972) _23972 _23971).
Proof. exact (eq_refl real_max). Qed.
Definition real_min : real -> real -> real := fun _23983 : real => fun _23984 : real => @COND real (real_le _23983 _23984) _23983 _23984.
Lemma real_min_def : real_min = (fun _23983 : real => fun _23984 : real => @COND real (real_le _23983 _23984) _23983 _23984).
Proof. exact (eq_refl real_min). Qed.
Definition real_sgn : real -> real := fun _26471 : real => @COND real (real_lt (real_of_num (NUMERAL 0)) _26471) (real_of_num (NUMERAL (BIT1 0))) (@COND real (real_lt _26471 (real_of_num (NUMERAL 0))) (real_neg (real_of_num (NUMERAL (BIT1 0)))) (real_of_num (NUMERAL 0))).
Lemma real_sgn_def : real_sgn = (fun _26471 : real => @COND real (real_lt (real_of_num (NUMERAL 0)) _26471) (real_of_num (NUMERAL (BIT1 0))) (@COND real (real_lt _26471 (real_of_num (NUMERAL 0))) (real_neg (real_of_num (NUMERAL (BIT1 0)))) (real_of_num (NUMERAL 0)))).
Proof. exact (eq_refl real_sgn). Qed.
Definition sqrt : real -> real := fun _27022 : real => @ε real (fun y : real => ((real_sgn y) = (real_sgn _27022)) /\ ((real_pow y (NUMERAL (BIT0 (BIT1 0)))) = (real_abs _27022))).
Lemma sqrt_def : sqrt = (fun _27022 : real => @ε real (fun y : real => ((real_sgn y) = (real_sgn _27022)) /\ ((real_pow y (NUMERAL (BIT0 (BIT1 0)))) = (real_abs _27022)))).
Proof. exact (eq_refl sqrt). Qed.
Definition DECIMAL : nat -> nat -> real := fun _27701 : nat => fun _27702 : nat => real_div (real_of_num _27701) (real_of_num _27702).
Lemma DECIMAL_def : DECIMAL = (fun _27701 : nat => fun _27702 : nat => real_div (real_of_num _27701) (real_of_num _27702)).
Proof. exact (eq_refl DECIMAL). Qed.
Definition integer : real -> Prop := fun _28588 : real => exists n : nat, (real_abs _28588) = (real_of_num n).
Lemma integer_def : integer = (fun _28588 : real => exists n : nat, (real_abs _28588) = (real_of_num n)).
Proof. exact (eq_refl integer). Qed.
Axiom int_of_real : real -> int.
Axiom real_of_int : int -> real.
Definition int_le : int -> int -> Prop := fun _28614 : int => fun _28615 : int => real_le (real_of_int _28614) (real_of_int _28615).
Lemma int_le_def : int_le = (fun _28614 : int => fun _28615 : int => real_le (real_of_int _28614) (real_of_int _28615)).
Proof. exact (eq_refl int_le). Qed.
Definition int_lt : int -> int -> Prop := fun _28626 : int => fun _28627 : int => real_lt (real_of_int _28626) (real_of_int _28627).
Lemma int_lt_def : int_lt = (fun _28626 : int => fun _28627 : int => real_lt (real_of_int _28626) (real_of_int _28627)).
Proof. exact (eq_refl int_lt). Qed.
Definition int_ge : int -> int -> Prop := fun _28638 : int => fun _28639 : int => real_ge (real_of_int _28638) (real_of_int _28639).
Lemma int_ge_def : int_ge = (fun _28638 : int => fun _28639 : int => real_ge (real_of_int _28638) (real_of_int _28639)).
Proof. exact (eq_refl int_ge). Qed.
Definition int_gt : int -> int -> Prop := fun _28650 : int => fun _28651 : int => real_gt (real_of_int _28650) (real_of_int _28651).
Lemma int_gt_def : int_gt = (fun _28650 : int => fun _28651 : int => real_gt (real_of_int _28650) (real_of_int _28651)).
Proof. exact (eq_refl int_gt). Qed.
Definition int_of_num : nat -> int := fun _28662 : nat => int_of_real (real_of_num _28662).
Lemma int_of_num_def : int_of_num = (fun _28662 : nat => int_of_real (real_of_num _28662)).
Proof. exact (eq_refl int_of_num). Qed.
Definition int_neg : int -> int := fun _28667 : int => int_of_real (real_neg (real_of_int _28667)).
Lemma int_neg_def : int_neg = (fun _28667 : int => int_of_real (real_neg (real_of_int _28667))).
Proof. exact (eq_refl int_neg). Qed.
Definition int_add : int -> int -> int := fun _28676 : int => fun _28677 : int => int_of_real (real_add (real_of_int _28676) (real_of_int _28677)).
Lemma int_add_def : int_add = (fun _28676 : int => fun _28677 : int => int_of_real (real_add (real_of_int _28676) (real_of_int _28677))).
Proof. exact (eq_refl int_add). Qed.
Definition int_sub : int -> int -> int := fun _28708 : int => fun _28709 : int => int_of_real (real_sub (real_of_int _28708) (real_of_int _28709)).
Lemma int_sub_def : int_sub = (fun _28708 : int => fun _28709 : int => int_of_real (real_sub (real_of_int _28708) (real_of_int _28709))).
Proof. exact (eq_refl int_sub). Qed.
Definition int_mul : int -> int -> int := fun _28720 : int => fun _28721 : int => int_of_real (real_mul (real_of_int _28720) (real_of_int _28721)).
Lemma int_mul_def : int_mul = (fun _28720 : int => fun _28721 : int => int_of_real (real_mul (real_of_int _28720) (real_of_int _28721))).
Proof. exact (eq_refl int_mul). Qed.
Definition int_abs : int -> int := fun _28740 : int => int_of_real (real_abs (real_of_int _28740)).
Lemma int_abs_def : int_abs = (fun _28740 : int => int_of_real (real_abs (real_of_int _28740))).
Proof. exact (eq_refl int_abs). Qed.
Definition int_sgn : int -> int := fun _28751 : int => int_of_real (real_sgn (real_of_int _28751)).
Lemma int_sgn_def : int_sgn = (fun _28751 : int => int_of_real (real_sgn (real_of_int _28751))).
Proof. exact (eq_refl int_sgn). Qed.
Definition int_max : int -> int -> int := fun _28811 : int => fun _28812 : int => int_of_real (real_max (real_of_int _28811) (real_of_int _28812)).
Lemma int_max_def : int_max = (fun _28811 : int => fun _28812 : int => int_of_real (real_max (real_of_int _28811) (real_of_int _28812))).
Proof. exact (eq_refl int_max). Qed.
Definition int_min : int -> int -> int := fun _28829 : int => fun _28830 : int => int_of_real (real_min (real_of_int _28829) (real_of_int _28830)).
Lemma int_min_def : int_min = (fun _28829 : int => fun _28830 : int => int_of_real (real_min (real_of_int _28829) (real_of_int _28830))).
Proof. exact (eq_refl int_min). Qed.
Definition int_pow : int -> nat -> int := fun _28847 : int => fun _28848 : nat => int_of_real (real_pow (real_of_int _28847) _28848).
Lemma int_pow_def : int_pow = (fun _28847 : int => fun _28848 : nat => int_of_real (real_pow (real_of_int _28847) _28848)).
Proof. exact (eq_refl int_pow). Qed.
Definition div : int -> int -> int := @ε ((prod nat (prod nat nat)) -> int -> int -> int) (fun q : (prod nat (prod nat nat)) -> int -> int -> int => forall _29199 : prod nat (prod nat nat), exists r : int -> int -> int, forall m : int, forall n : int, @COND Prop (n = (int_of_num (NUMERAL 0))) (((q _29199 m n) = (int_of_num (NUMERAL 0))) /\ ((r m n) = m)) ((int_le (int_of_num (NUMERAL 0)) (r m n)) /\ ((int_lt (r m n) (int_abs n)) /\ (m = (int_add (int_mul (q _29199 m n) n) (r m n)))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))))).
Lemma div_def : div = (@ε ((prod nat (prod nat nat)) -> int -> int -> int) (fun q : (prod nat (prod nat nat)) -> int -> int -> int => forall _29199 : prod nat (prod nat nat), exists r : int -> int -> int, forall m : int, forall n : int, @COND Prop (n = (int_of_num (NUMERAL 0))) (((q _29199 m n) = (int_of_num (NUMERAL 0))) /\ ((r m n) = m)) ((int_le (int_of_num (NUMERAL 0)) (r m n)) /\ ((int_lt (r m n) (int_abs n)) /\ (m = (int_add (int_mul (q _29199 m n) n) (r m n)))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0))))))))))).
Proof. exact (eq_refl div). Qed.
Definition rem : int -> int -> int := @ε ((prod nat (prod nat nat)) -> int -> int -> int) (fun r : (prod nat (prod nat nat)) -> int -> int -> int => forall _29200 : prod nat (prod nat nat), forall m : int, forall n : int, @COND Prop (n = (int_of_num (NUMERAL 0))) (((div m n) = (int_of_num (NUMERAL 0))) /\ ((r _29200 m n) = m)) ((int_le (int_of_num (NUMERAL 0)) (r _29200 m n)) /\ ((int_lt (r _29200 m n) (int_abs n)) /\ (m = (int_add (int_mul (div m n) n) (r _29200 m n)))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))))).
Lemma rem_def : rem = (@ε ((prod nat (prod nat nat)) -> int -> int -> int) (fun r : (prod nat (prod nat nat)) -> int -> int -> int => forall _29200 : prod nat (prod nat nat), forall m : int, forall n : int, @COND Prop (n = (int_of_num (NUMERAL 0))) (((div m n) = (int_of_num (NUMERAL 0))) /\ ((r _29200 m n) = m)) ((int_le (int_of_num (NUMERAL 0)) (r _29200 m n)) /\ ((int_lt (r _29200 m n) (int_abs n)) /\ (m = (int_add (int_mul (div m n) n) (r _29200 m n)))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0))))))))))).
Proof. exact (eq_refl rem). Qed.
Definition eq2 {A : Type'} : A -> A -> (A -> A -> Prop) -> Prop := fun _29475 : A => fun _29476 : A => fun _29477 : A -> A -> Prop => _29477 _29475 _29476.
Lemma eq2_def {A : Type'} : (@eq2 A) = (fun _29475 : A => fun _29476 : A => fun _29477 : A -> A -> Prop => _29477 _29475 _29476).
Proof. exact (eq_refl (@eq2 A)). Qed.
Definition real_mod : real -> real -> real -> Prop := fun _29496 : real => fun _29497 : real => fun _29498 : real => exists q : real, (integer q) /\ ((real_sub _29497 _29498) = (real_mul q _29496)).
Lemma real_mod_def : real_mod = (fun _29496 : real => fun _29497 : real => fun _29498 : real => exists q : real, (integer q) /\ ((real_sub _29497 _29498) = (real_mul q _29496))).
Proof. exact (eq_refl real_mod). Qed.
Definition int_divides : int -> int -> Prop := fun _29517 : int => fun _29518 : int => exists x : int, _29518 = (int_mul _29517 x).
Lemma int_divides_def : int_divides = (fun _29517 : int => fun _29518 : int => exists x : int, _29518 = (int_mul _29517 x)).
Proof. exact (eq_refl int_divides). Qed.
Definition int_mod : int -> int -> int -> Prop := fun _29537 : int => fun _29538 : int => fun _29539 : int => int_divides _29537 (int_sub _29538 _29539).
Lemma int_mod_def : int_mod = (fun _29537 : int => fun _29538 : int => fun _29539 : int => int_divides _29537 (int_sub _29538 _29539)).
Proof. exact (eq_refl int_mod). Qed.
Definition int_coprime : (prod int int) -> Prop := fun _29564 : prod int int => exists x : int, exists y : int, (int_add (int_mul (@fst int int _29564) x) (int_mul (@snd int int _29564) y)) = (int_of_num (NUMERAL (BIT1 0))).
Lemma int_coprime_def : int_coprime = (fun _29564 : prod int int => exists x : int, exists y : int, (int_add (int_mul (@fst int int _29564) x) (int_mul (@snd int int _29564) y)) = (int_of_num (NUMERAL (BIT1 0)))).
Proof. exact (eq_refl int_coprime). Qed.
Definition int_gcd : (prod int int) -> int := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (prod int int) -> int) (fun d : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (prod int int) -> int => forall _30833 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))), forall a : int, forall b : int, (int_le (int_of_num (NUMERAL 0)) (d _30833 (@pair int int a b))) /\ ((int_divides (d _30833 (@pair int int a b)) a) /\ ((int_divides (d _30833 (@pair int int a b)) b) /\ (exists x : int, exists y : int, (d _30833 (@pair int int a b)) = (int_add (int_mul a x) (int_mul b y)))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))))))))).
Lemma int_gcd_def : int_gcd = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (prod int int) -> int) (fun d : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (prod int int) -> int => forall _30833 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))), forall a : int, forall b : int, (int_le (int_of_num (NUMERAL 0)) (d _30833 (@pair int int a b))) /\ ((int_divides (d _30833 (@pair int int a b)) a) /\ ((int_divides (d _30833 (@pair int int a b)) b) /\ (exists x : int, exists y : int, (d _30833 (@pair int int a b)) = (int_add (int_mul a x) (int_mul b y)))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0))))))))))))))).
Proof. exact (eq_refl int_gcd). Qed.
Definition int_lcm : (prod int int) -> int := fun _30834 : prod int int => @COND int ((int_mul (@fst int int _30834) (@snd int int _30834)) = (int_of_num (NUMERAL 0))) (int_of_num (NUMERAL 0)) (div (int_abs (int_mul (@fst int int _30834) (@snd int int _30834))) (int_gcd (@pair int int (@fst int int _30834) (@snd int int _30834)))).
Lemma int_lcm_def : int_lcm = (fun _30834 : prod int int => @COND int ((int_mul (@fst int int _30834) (@snd int int _30834)) = (int_of_num (NUMERAL 0))) (int_of_num (NUMERAL 0)) (div (int_abs (int_mul (@fst int int _30834) (@snd int int _30834))) (int_gcd (@pair int int (@fst int int _30834) (@snd int int _30834))))).
Proof. exact (eq_refl int_lcm). Qed.
Definition num_of_int : int -> nat := fun _31107 : int => @ε nat (fun n : nat => (int_of_num n) = _31107).
Lemma num_of_int_def : num_of_int = (fun _31107 : int => @ε nat (fun n : nat => (int_of_num n) = _31107)).
Proof. exact (eq_refl num_of_int). Qed.
Definition num_divides : nat -> nat -> Prop := fun _31139 : nat => fun _31140 : nat => int_divides (int_of_num _31139) (int_of_num _31140).
Lemma num_divides_def : num_divides = (fun _31139 : nat => fun _31140 : nat => int_divides (int_of_num _31139) (int_of_num _31140)).
Proof. exact (eq_refl num_divides). Qed.
Definition num_mod : nat -> nat -> nat -> Prop := fun _31151 : nat => fun _31152 : nat => fun _31153 : nat => int_mod (int_of_num _31151) (int_of_num _31152) (int_of_num _31153).
Lemma num_mod_def : num_mod = (fun _31151 : nat => fun _31152 : nat => fun _31153 : nat => int_mod (int_of_num _31151) (int_of_num _31152) (int_of_num _31153)).
Proof. exact (eq_refl num_mod). Qed.
Definition num_coprime : (prod nat nat) -> Prop := fun _31172 : prod nat nat => int_coprime (@pair int int (int_of_num (@fst nat nat _31172)) (int_of_num (@snd nat nat _31172))).
Lemma num_coprime_def : num_coprime = (fun _31172 : prod nat nat => int_coprime (@pair int int (int_of_num (@fst nat nat _31172)) (int_of_num (@snd nat nat _31172)))).
Proof. exact (eq_refl num_coprime). Qed.
Definition num_gcd : (prod nat nat) -> nat := fun _31181 : prod nat nat => num_of_int (int_gcd (@pair int int (int_of_num (@fst nat nat _31181)) (int_of_num (@snd nat nat _31181)))).
Lemma num_gcd_def : num_gcd = (fun _31181 : prod nat nat => num_of_int (int_gcd (@pair int int (int_of_num (@fst nat nat _31181)) (int_of_num (@snd nat nat _31181))))).
Proof. exact (eq_refl num_gcd). Qed.
Definition num_lcm : (prod nat nat) -> nat := fun _31190 : prod nat nat => num_of_int (int_lcm (@pair int int (int_of_num (@fst nat nat _31190)) (int_of_num (@snd nat nat _31190)))).
Lemma num_lcm_def : num_lcm = (fun _31190 : prod nat nat => num_of_int (int_lcm (@pair int int (int_of_num (@fst nat nat _31190)) (int_of_num (@snd nat nat _31190))))).
Proof. exact (eq_refl num_lcm). Qed.
Definition prime : nat -> Prop := fun _32468 : nat => (~ (_32468 = (NUMERAL (BIT1 0)))) /\ (forall x : nat, (num_divides x _32468) -> (x = (NUMERAL (BIT1 0))) \/ (x = _32468)).
Lemma prime_def : prime = (fun _32468 : nat => (~ (_32468 = (NUMERAL (BIT1 0)))) /\ (forall x : nat, (num_divides x _32468) -> (x = (NUMERAL (BIT1 0))) \/ (x = _32468))).
Proof. exact (eq_refl prime). Qed.
Definition real_zpow : real -> int -> real := fun _32626 : real => fun _32627 : int => @COND real (int_le (int_of_num (NUMERAL 0)) _32627) (real_pow _32626 (num_of_int _32627)) (real_inv (real_pow _32626 (num_of_int (int_neg _32627)))).
Lemma real_zpow_def : real_zpow = (fun _32626 : real => fun _32627 : int => @COND real (int_le (int_of_num (NUMERAL 0)) _32627) (real_pow _32626 (num_of_int _32627)) (real_inv (real_pow _32626 (num_of_int (int_neg _32627))))).
Proof. exact (eq_refl real_zpow). Qed.
Definition IN {A : Type'} : A -> (A -> Prop) -> Prop := fun _32683 : A => fun _32684 : A -> Prop => _32684 _32683.
Lemma IN_def {A : Type'} : (@IN A) = (fun _32683 : A => fun _32684 : A -> Prop => _32684 _32683).
Proof. exact (eq_refl (@IN A)). Qed.
Definition GSPEC {A : Type'} : (A -> Prop) -> A -> Prop := fun _32695 : A -> Prop => _32695.
Lemma GSPEC_def {A : Type'} : (@GSPEC A) = (fun _32695 : A -> Prop => _32695).
Proof. exact (eq_refl (@GSPEC A)). Qed.
Definition SETSPEC {_83031 : Type'} : _83031 -> Prop -> _83031 -> Prop := fun _32700 : _83031 => fun _32701 : Prop => fun _32702 : _83031 => _32701 /\ (_32700 = _32702).
Lemma SETSPEC_def {_83031 : Type'} : (@SETSPEC _83031) = (fun _32700 : _83031 => fun _32701 : Prop => fun _32702 : _83031 => _32701 /\ (_32700 = _32702)).
Proof. exact (eq_refl (@SETSPEC _83031)). Qed.
Definition EMPTY {A : Type'} : A -> Prop := fun x : A => False.
Lemma EMPTY_def {A : Type'} : (@EMPTY A) = (fun x : A => False).
Proof. exact (eq_refl (@EMPTY A)). Qed.
Definition INSERT {A : Type'} : A -> (A -> Prop) -> A -> Prop := fun _32739 : A => fun _32740 : A -> Prop => fun y : A => (@IN A y _32740) \/ (y = _32739).
Lemma INSERT_def {A : Type'} : (@INSERT A) = (fun _32739 : A => fun _32740 : A -> Prop => fun y : A => (@IN A y _32740) \/ (y = _32739)).
Proof. exact (eq_refl (@INSERT A)). Qed.
Definition UNIV {A : Type'} : A -> Prop := fun x : A => True.
Lemma UNIV_def {A : Type'} : (@UNIV A) = (fun x : A => True).
Proof. exact (eq_refl (@UNIV A)). Qed.
Definition UNION {A : Type'} : (A -> Prop) -> (A -> Prop) -> A -> Prop := fun _32751 : A -> Prop => fun _32752 : A -> Prop => @GSPEC A (fun GEN_PVAR_0 : A => exists x : A, @SETSPEC A GEN_PVAR_0 ((@IN A x _32751) \/ (@IN A x _32752)) x).
Lemma UNION_def {A : Type'} : (@UNION A) = (fun _32751 : A -> Prop => fun _32752 : A -> Prop => @GSPEC A (fun GEN_PVAR_0 : A => exists x : A, @SETSPEC A GEN_PVAR_0 ((@IN A x _32751) \/ (@IN A x _32752)) x)).
Proof. exact (eq_refl (@UNION A)). Qed.
Definition UNIONS {A : Type'} : ((A -> Prop) -> Prop) -> A -> Prop := fun _32763 : (A -> Prop) -> Prop => @GSPEC A (fun GEN_PVAR_1 : A => exists x : A, @SETSPEC A GEN_PVAR_1 (exists u : A -> Prop, (@IN (A -> Prop) u _32763) /\ (@IN A x u)) x).
Lemma UNIONS_def {A : Type'} : (@UNIONS A) = (fun _32763 : (A -> Prop) -> Prop => @GSPEC A (fun GEN_PVAR_1 : A => exists x : A, @SETSPEC A GEN_PVAR_1 (exists u : A -> Prop, (@IN (A -> Prop) u _32763) /\ (@IN A x u)) x)).
Proof. exact (eq_refl (@UNIONS A)). Qed.
Definition INTER {A : Type'} : (A -> Prop) -> (A -> Prop) -> A -> Prop := fun _32768 : A -> Prop => fun _32769 : A -> Prop => @GSPEC A (fun GEN_PVAR_2 : A => exists x : A, @SETSPEC A GEN_PVAR_2 ((@IN A x _32768) /\ (@IN A x _32769)) x).
Lemma INTER_def {A : Type'} : (@INTER A) = (fun _32768 : A -> Prop => fun _32769 : A -> Prop => @GSPEC A (fun GEN_PVAR_2 : A => exists x : A, @SETSPEC A GEN_PVAR_2 ((@IN A x _32768) /\ (@IN A x _32769)) x)).
Proof. exact (eq_refl (@INTER A)). Qed.
Definition INTERS {A : Type'} : ((A -> Prop) -> Prop) -> A -> Prop := fun _32780 : (A -> Prop) -> Prop => @GSPEC A (fun GEN_PVAR_3 : A => exists x : A, @SETSPEC A GEN_PVAR_3 (forall u : A -> Prop, (@IN (A -> Prop) u _32780) -> @IN A x u) x).
Lemma INTERS_def {A : Type'} : (@INTERS A) = (fun _32780 : (A -> Prop) -> Prop => @GSPEC A (fun GEN_PVAR_3 : A => exists x : A, @SETSPEC A GEN_PVAR_3 (forall u : A -> Prop, (@IN (A -> Prop) u _32780) -> @IN A x u) x)).
Proof. exact (eq_refl (@INTERS A)). Qed.
Definition DIFF {A : Type'} : (A -> Prop) -> (A -> Prop) -> A -> Prop := fun _32785 : A -> Prop => fun _32786 : A -> Prop => @GSPEC A (fun GEN_PVAR_4 : A => exists x : A, @SETSPEC A GEN_PVAR_4 ((@IN A x _32785) /\ (~ (@IN A x _32786))) x).
Lemma DIFF_def {A : Type'} : (@DIFF A) = (fun _32785 : A -> Prop => fun _32786 : A -> Prop => @GSPEC A (fun GEN_PVAR_4 : A => exists x : A, @SETSPEC A GEN_PVAR_4 ((@IN A x _32785) /\ (~ (@IN A x _32786))) x)).
Proof. exact (eq_refl (@DIFF A)). Qed.
Definition DELETE {A : Type'} : (A -> Prop) -> A -> A -> Prop := fun _32797 : A -> Prop => fun _32798 : A => @GSPEC A (fun GEN_PVAR_6 : A => exists y : A, @SETSPEC A GEN_PVAR_6 ((@IN A y _32797) /\ (~ (y = _32798))) y).
Lemma DELETE_def {A : Type'} : (@DELETE A) = (fun _32797 : A -> Prop => fun _32798 : A => @GSPEC A (fun GEN_PVAR_6 : A => exists y : A, @SETSPEC A GEN_PVAR_6 ((@IN A y _32797) /\ (~ (y = _32798))) y)).
Proof. exact (eq_refl (@DELETE A)). Qed.
Definition SUBSET {A : Type'} : (A -> Prop) -> (A -> Prop) -> Prop := fun _32809 : A -> Prop => fun _32810 : A -> Prop => forall x : A, (@IN A x _32809) -> @IN A x _32810.
Lemma SUBSET_def {A : Type'} : (@SUBSET A) = (fun _32809 : A -> Prop => fun _32810 : A -> Prop => forall x : A, (@IN A x _32809) -> @IN A x _32810).
Proof. exact (eq_refl (@SUBSET A)). Qed.
Definition PSUBSET {A : Type'} : (A -> Prop) -> (A -> Prop) -> Prop := fun _32821 : A -> Prop => fun _32822 : A -> Prop => (@SUBSET A _32821 _32822) /\ (~ (_32821 = _32822)).
Lemma PSUBSET_def {A : Type'} : (@PSUBSET A) = (fun _32821 : A -> Prop => fun _32822 : A -> Prop => (@SUBSET A _32821 _32822) /\ (~ (_32821 = _32822))).
Proof. exact (eq_refl (@PSUBSET A)). Qed.
Definition DISJOINT {A : Type'} : (A -> Prop) -> (A -> Prop) -> Prop := fun _32833 : A -> Prop => fun _32834 : A -> Prop => (@INTER A _32833 _32834) = (@EMPTY A).
Lemma DISJOINT_def {A : Type'} : (@DISJOINT A) = (fun _32833 : A -> Prop => fun _32834 : A -> Prop => (@INTER A _32833 _32834) = (@EMPTY A)).
Proof. exact (eq_refl (@DISJOINT A)). Qed.
Definition SING {A : Type'} : (A -> Prop) -> Prop := fun _32845 : A -> Prop => exists x : A, _32845 = (@INSERT A x (@EMPTY A)).
Lemma SING_def {A : Type'} : (@SING A) = (fun _32845 : A -> Prop => exists x : A, _32845 = (@INSERT A x (@EMPTY A))).
Proof. exact (eq_refl (@SING A)). Qed.
Definition FINITE {A : Type'} : (A -> Prop) -> Prop := fun a : A -> Prop => forall FINITE' : (A -> Prop) -> Prop, (forall a' : A -> Prop, ((a' = (@EMPTY A)) \/ (exists x : A, exists s : A -> Prop, (a' = (@INSERT A x s)) /\ (FINITE' s))) -> FINITE' a') -> FINITE' a.
Lemma FINITE_def {A : Type'} : (@FINITE A) = (fun a : A -> Prop => forall FINITE' : (A -> Prop) -> Prop, (forall a' : A -> Prop, ((a' = (@EMPTY A)) \/ (exists x : A, exists s : A -> Prop, (a' = (@INSERT A x s)) /\ (FINITE' s))) -> FINITE' a') -> FINITE' a).
Proof. exact (eq_refl (@FINITE A)). Qed.
Definition INFINITE {A : Type'} : (A -> Prop) -> Prop := fun _32854 : A -> Prop => ~ (@FINITE A _32854).
Lemma INFINITE_def {A : Type'} : (@INFINITE A) = (fun _32854 : A -> Prop => ~ (@FINITE A _32854)).
Proof. exact (eq_refl (@INFINITE A)). Qed.
Definition IMAGE {A B : Type'} : (A -> B) -> (A -> Prop) -> B -> Prop := fun _32859 : A -> B => fun _32860 : A -> Prop => @GSPEC B (fun GEN_PVAR_7 : B => exists y : B, @SETSPEC B GEN_PVAR_7 (exists x : A, (@IN A x _32860) /\ (y = (_32859 x))) y).
Lemma IMAGE_def {A B : Type'} : (@IMAGE A B) = (fun _32859 : A -> B => fun _32860 : A -> Prop => @GSPEC B (fun GEN_PVAR_7 : B => exists y : B, @SETSPEC B GEN_PVAR_7 (exists x : A, (@IN A x _32860) /\ (y = (_32859 x))) y)).
Proof. exact (eq_refl (@IMAGE A B)). Qed.
Definition INJ {A B : Type'} : (A -> B) -> (A -> Prop) -> (B -> Prop) -> Prop := fun _32871 : A -> B => fun _32872 : A -> Prop => fun _32873 : B -> Prop => (forall x : A, (@IN A x _32872) -> @IN B (_32871 x) _32873) /\ (forall x : A, forall y : A, ((@IN A x _32872) /\ ((@IN A y _32872) /\ ((_32871 x) = (_32871 y)))) -> x = y).
Lemma INJ_def {A B : Type'} : (@INJ A B) = (fun _32871 : A -> B => fun _32872 : A -> Prop => fun _32873 : B -> Prop => (forall x : A, (@IN A x _32872) -> @IN B (_32871 x) _32873) /\ (forall x : A, forall y : A, ((@IN A x _32872) /\ ((@IN A y _32872) /\ ((_32871 x) = (_32871 y)))) -> x = y)).
Proof. exact (eq_refl (@INJ A B)). Qed.
Definition SURJ {A B : Type'} : (A -> B) -> (A -> Prop) -> (B -> Prop) -> Prop := fun _32892 : A -> B => fun _32893 : A -> Prop => fun _32894 : B -> Prop => (forall x : A, (@IN A x _32893) -> @IN B (_32892 x) _32894) /\ (forall x : B, (@IN B x _32894) -> exists y : A, (@IN A y _32893) /\ ((_32892 y) = x)).
Lemma SURJ_def {A B : Type'} : (@SURJ A B) = (fun _32892 : A -> B => fun _32893 : A -> Prop => fun _32894 : B -> Prop => (forall x : A, (@IN A x _32893) -> @IN B (_32892 x) _32894) /\ (forall x : B, (@IN B x _32894) -> exists y : A, (@IN A y _32893) /\ ((_32892 y) = x))).
Proof. exact (eq_refl (@SURJ A B)). Qed.
Definition BIJ {A B : Type'} : (A -> B) -> (A -> Prop) -> (B -> Prop) -> Prop := fun _32913 : A -> B => fun _32914 : A -> Prop => fun _32915 : B -> Prop => (@INJ A B _32913 _32914 _32915) /\ (@SURJ A B _32913 _32914 _32915).
Lemma BIJ_def {A B : Type'} : (@BIJ A B) = (fun _32913 : A -> B => fun _32914 : A -> Prop => fun _32915 : B -> Prop => (@INJ A B _32913 _32914 _32915) /\ (@SURJ A B _32913 _32914 _32915)).
Proof. exact (eq_refl (@BIJ A B)). Qed.
Definition CHOICE {A : Type'} : (A -> Prop) -> A := fun _32934 : A -> Prop => @ε A (fun x : A => @IN A x _32934).
Lemma CHOICE_def {A : Type'} : (@CHOICE A) = (fun _32934 : A -> Prop => @ε A (fun x : A => @IN A x _32934)).
Proof. exact (eq_refl (@CHOICE A)). Qed.
Definition REST {A : Type'} : (A -> Prop) -> A -> Prop := fun _32939 : A -> Prop => @DELETE A _32939 (@CHOICE A _32939).
Lemma REST_def {A : Type'} : (@REST A) = (fun _32939 : A -> Prop => @DELETE A _32939 (@CHOICE A _32939)).
Proof. exact (eq_refl (@REST A)). Qed.
Definition FINREC {A B : Type'} : (A -> B -> B) -> B -> (A -> Prop) -> B -> nat -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> nat -> Prop) (fun FINREC' : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> nat -> Prop => forall _43486 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), (forall f : A -> B -> B, forall s : A -> Prop, forall a : B, forall b : B, (FINREC' _43486 f b s a (NUMERAL 0)) = ((s = (@EMPTY A)) /\ (a = b))) /\ (forall b : B, forall s : A -> Prop, forall n : nat, forall a : B, forall f : A -> B -> B, (FINREC' _43486 f b s a (S n)) = (exists x : A, exists c : B, (@IN A x s) /\ ((FINREC' _43486 f b (@DELETE A s x) c n) /\ (a = (f x c)))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0))))))))))))).
Lemma FINREC_def {A B : Type'} : (@FINREC A B) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> nat -> Prop) (fun FINREC' : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> nat -> Prop => forall _43486 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), (forall f : A -> B -> B, forall s : A -> Prop, forall a : B, forall b : B, (FINREC' _43486 f b s a (NUMERAL 0)) = ((s = (@EMPTY A)) /\ (a = b))) /\ (forall b : B, forall s : A -> Prop, forall n : nat, forall a : B, forall f : A -> B -> B, (FINREC' _43486 f b s a (S n)) = (exists x : A, exists c : B, (@IN A x s) /\ ((FINREC' _43486 f b (@DELETE A s x) c n) /\ (a = (f x c)))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))))))))).
Proof. exact (eq_refl (@FINREC A B)). Qed.
Definition ITSET {_99240 _99241 : Type'} : (_99241 -> _99240 -> _99240) -> (_99241 -> Prop) -> _99240 -> _99240 := fun _44336 : _99241 -> _99240 -> _99240 => fun _44337 : _99241 -> Prop => fun _44338 : _99240 => @ε ((_99241 -> Prop) -> _99240) (fun g : (_99241 -> Prop) -> _99240 => ((g (@EMPTY _99241)) = _44338) /\ (forall x : _99241, forall s : _99241 -> Prop, (@FINITE _99241 s) -> (g (@INSERT _99241 x s)) = (@COND _99240 (@IN _99241 x s) (g s) (_44336 x (g s))))) _44337.
Lemma ITSET_def {_99240 _99241 : Type'} : (@ITSET _99240 _99241) = (fun _44336 : _99241 -> _99240 -> _99240 => fun _44337 : _99241 -> Prop => fun _44338 : _99240 => @ε ((_99241 -> Prop) -> _99240) (fun g : (_99241 -> Prop) -> _99240 => ((g (@EMPTY _99241)) = _44338) /\ (forall x : _99241, forall s : _99241 -> Prop, (@FINITE _99241 s) -> (g (@INSERT _99241 x s)) = (@COND _99240 (@IN _99241 x s) (g s) (_44336 x (g s))))) _44337).
Proof. exact (eq_refl (@ITSET _99240 _99241)). Qed.
Definition CARD {_99571 : Type'} : (_99571 -> Prop) -> nat := fun _44539 : _99571 -> Prop => @ITSET nat _99571 (fun x : _99571 => fun n : nat => S n) _44539 (NUMERAL 0).
Lemma CARD_def {_99571 : Type'} : (@CARD _99571) = (fun _44539 : _99571 -> Prop => @ITSET nat _99571 (fun x : _99571 => fun n : nat => S n) _44539 (NUMERAL 0)).
Proof. exact (eq_refl (@CARD _99571)). Qed.
Definition HAS_SIZE {_100044 : Type'} : (_100044 -> Prop) -> nat -> Prop := fun _44754 : _100044 -> Prop => fun _44755 : nat => (@FINITE _100044 _44754) /\ ((@CARD _100044 _44754) = _44755).
Lemma HAS_SIZE_def {_100044 : Type'} : (@HAS_SIZE _100044) = (fun _44754 : _100044 -> Prop => fun _44755 : nat => (@FINITE _100044 _44754) /\ ((@CARD _100044 _44754) = _44755)).
Proof. exact (eq_refl (@HAS_SIZE _100044)). Qed.
Definition CROSS {_103681 _103682 : Type'} : (_103682 -> Prop) -> (_103681 -> Prop) -> (prod _103682 _103681) -> Prop := fun _49274 : _103682 -> Prop => fun _49275 : _103681 -> Prop => @GSPEC (prod _103682 _103681) (fun GEN_PVAR_130 : prod _103682 _103681 => exists x : _103682, exists y : _103681, @SETSPEC (prod _103682 _103681) GEN_PVAR_130 ((@IN _103682 x _49274) /\ (@IN _103681 y _49275)) (@pair _103682 _103681 x y)).
Lemma CROSS_def {_103681 _103682 : Type'} : (@CROSS _103681 _103682) = (fun _49274 : _103682 -> Prop => fun _49275 : _103681 -> Prop => @GSPEC (prod _103682 _103681) (fun GEN_PVAR_130 : prod _103682 _103681 => exists x : _103682, exists y : _103681, @SETSPEC (prod _103682 _103681) GEN_PVAR_130 ((@IN _103682 x _49274) /\ (@IN _103681 y _49275)) (@pair _103682 _103681 x y))).
Proof. exact (eq_refl (@CROSS _103681 _103682)). Qed.
Definition ARB {A : Type'} : A := @ε A (fun x : A => False).
Lemma ARB_def {A : Type'} : (@ARB A) = (@ε A (fun x : A => False)).
Proof. exact (eq_refl (@ARB A)). Qed.
Definition EXTENSIONAL {A B : Type'} : (A -> Prop) -> (A -> B) -> Prop := fun _50046 : A -> Prop => @GSPEC (A -> B) (fun GEN_PVAR_139 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_139 (forall x : A, (~ (@IN A x _50046)) -> (f x) = (@ARB B)) f).
Lemma EXTENSIONAL_def {A B : Type'} : (@EXTENSIONAL A B) = (fun _50046 : A -> Prop => @GSPEC (A -> B) (fun GEN_PVAR_139 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_139 (forall x : A, (~ (@IN A x _50046)) -> (f x) = (@ARB B)) f)).
Proof. exact (eq_refl (@EXTENSIONAL A B)). Qed.
Definition RESTRICTION {A B : Type'} : (A -> Prop) -> (A -> B) -> A -> B := fun _50098 : A -> Prop => fun _50099 : A -> B => fun _50100 : A => @COND B (@IN A _50100 _50098) (_50099 _50100) (@ARB B).
Lemma RESTRICTION_def {A B : Type'} : (@RESTRICTION A B) = (fun _50098 : A -> Prop => fun _50099 : A -> B => fun _50100 : A => @COND B (@IN A _50100 _50098) (_50099 _50100) (@ARB B)).
Proof. exact (eq_refl (@RESTRICTION A B)). Qed.
Definition cartesian_product {A K : Type'} : (K -> Prop) -> (K -> A -> Prop) -> (K -> A) -> Prop := fun _50293 : K -> Prop => fun _50294 : K -> A -> Prop => @GSPEC (K -> A) (fun GEN_PVAR_140 : K -> A => exists f : K -> A, @SETSPEC (K -> A) GEN_PVAR_140 ((@EXTENSIONAL K A _50293 f) /\ (forall i : K, (@IN K i _50293) -> @IN A (f i) (_50294 i))) f).
Lemma cartesian_product_def {A K : Type'} : (@cartesian_product A K) = (fun _50293 : K -> Prop => fun _50294 : K -> A -> Prop => @GSPEC (K -> A) (fun GEN_PVAR_140 : K -> A => exists f : K -> A, @SETSPEC (K -> A) GEN_PVAR_140 ((@EXTENSIONAL K A _50293 f) /\ (forall i : K, (@IN K i _50293) -> @IN A (f i) (_50294 i))) f)).
Proof. exact (eq_refl (@cartesian_product A K)). Qed.
Definition product_map {A B K : Type'} : (K -> Prop) -> (K -> A -> B) -> (K -> A) -> K -> B := fun _51526 : K -> Prop => fun _51527 : K -> A -> B => fun x : K -> A => @RESTRICTION K B _51526 (fun i : K => _51527 i (x i)).
Lemma product_map_def {A B K : Type'} : (@product_map A B K) = (fun _51526 : K -> Prop => fun _51527 : K -> A -> B => fun x : K -> A => @RESTRICTION K B _51526 (fun i : K => _51527 i (x i))).
Proof. exact (eq_refl (@product_map A B K)). Qed.
Definition disjoint_union {A K : Type'} : (K -> Prop) -> (K -> A -> Prop) -> (prod K A) -> Prop := fun _51662 : K -> Prop => fun _51663 : K -> A -> Prop => @GSPEC (prod K A) (fun GEN_PVAR_143 : prod K A => exists i : K, exists x : A, @SETSPEC (prod K A) GEN_PVAR_143 ((@IN K i _51662) /\ (@IN A x (_51663 i))) (@pair K A i x)).
Lemma disjoint_union_def {A K : Type'} : (@disjoint_union A K) = (fun _51662 : K -> Prop => fun _51663 : K -> A -> Prop => @GSPEC (prod K A) (fun GEN_PVAR_143 : prod K A => exists i : K, exists x : A, @SETSPEC (prod K A) GEN_PVAR_143 ((@IN K i _51662) /\ (@IN A x (_51663 i))) (@pair K A i x))).
Proof. exact (eq_refl (@disjoint_union A K)). Qed.
Definition set_of_list {A : Type'} : (list A) -> A -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (list A) -> A -> Prop) (fun set_of_list' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (list A) -> A -> Prop => forall _59117 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))), ((set_of_list' _59117 (@nil A)) = (@EMPTY A)) /\ (forall h : A, forall t : list A, (set_of_list' _59117 (@cons A h t)) = (@INSERT A h (set_of_list' _59117 t)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))))))))))))).
Lemma set_of_list_def {A : Type'} : (@set_of_list A) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (list A) -> A -> Prop) (fun set_of_list' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (list A) -> A -> Prop => forall _59117 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))), ((set_of_list' _59117 (@nil A)) = (@EMPTY A)) /\ (forall h : A, forall t : list A, (set_of_list' _59117 (@cons A h t)) = (@INSERT A h (set_of_list' _59117 t)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0))))))))))))))))))).
Proof. exact (eq_refl (@set_of_list A)). Qed.
Definition list_of_set {_110256 : Type'} : (_110256 -> Prop) -> list _110256 := fun _59118 : _110256 -> Prop => @ε (list _110256) (fun l : list _110256 => ((@set_of_list _110256 l) = _59118) /\ ((@List.length _110256 l) = (@CARD _110256 _59118))).
Lemma list_of_set_def {_110256 : Type'} : (@list_of_set _110256) = (fun _59118 : _110256 -> Prop => @ε (list _110256) (fun l : list _110256 => ((@set_of_list _110256 l) = _59118) /\ ((@List.length _110256 l) = (@CARD _110256 _59118)))).
Proof. exact (eq_refl (@list_of_set _110256)). Qed.
Definition pairwise {_110510 : Type'} : (_110510 -> _110510 -> Prop) -> (_110510 -> Prop) -> Prop := fun _59319 : _110510 -> _110510 -> Prop => fun _59320 : _110510 -> Prop => forall x : _110510, forall y : _110510, ((@IN _110510 x _59320) /\ ((@IN _110510 y _59320) /\ (~ (x = y)))) -> _59319 x y.
Lemma pairwise_def {_110510 : Type'} : (@pairwise _110510) = (fun _59319 : _110510 -> _110510 -> Prop => fun _59320 : _110510 -> Prop => forall x : _110510, forall y : _110510, ((@IN _110510 x _59320) /\ ((@IN _110510 y _59320) /\ (~ (x = y)))) -> _59319 x y).
Proof. exact (eq_refl (@pairwise _110510)). Qed.
Definition UNION_OF {A : Type'} : (((A -> Prop) -> Prop) -> Prop) -> ((A -> Prop) -> Prop) -> (A -> Prop) -> Prop := fun _60032 : ((A -> Prop) -> Prop) -> Prop => fun _60033 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_60032 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _60033 c) /\ ((@UNIONS A u) = s)).
Lemma UNION_OF_def {A : Type'} : (@UNION_OF A) = (fun _60032 : ((A -> Prop) -> Prop) -> Prop => fun _60033 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_60032 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _60033 c) /\ ((@UNIONS A u) = s))).
Proof. exact (eq_refl (@UNION_OF A)). Qed.
Definition INTERSECTION_OF {A : Type'} : (((A -> Prop) -> Prop) -> Prop) -> ((A -> Prop) -> Prop) -> (A -> Prop) -> Prop := fun _60044 : ((A -> Prop) -> Prop) -> Prop => fun _60045 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_60044 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _60045 c) /\ ((@INTERS A u) = s)).
Lemma INTERSECTION_OF_def {A : Type'} : (@INTERSECTION_OF A) = (fun _60044 : ((A -> Prop) -> Prop) -> Prop => fun _60045 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_60044 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _60045 c) /\ ((@INTERS A u) = s))).
Proof. exact (eq_refl (@INTERSECTION_OF A)). Qed.
Definition ARBITRARY {A : Type'} : ((A -> Prop) -> Prop) -> Prop := fun _60180 : (A -> Prop) -> Prop => True.
Lemma ARBITRARY_def {A : Type'} : (@ARBITRARY A) = (fun _60180 : (A -> Prop) -> Prop => True).
Proof. exact (eq_refl (@ARBITRARY A)). Qed.
Definition le_c {_114929 _114934 : Type'} : (_114934 -> Prop) -> (_114929 -> Prop) -> Prop := fun _66841 : _114934 -> Prop => fun _66842 : _114929 -> Prop => exists f : _114934 -> _114929, (forall x : _114934, (@IN _114934 x _66841) -> @IN _114929 (f x) _66842) /\ (forall x : _114934, forall y : _114934, ((@IN _114934 x _66841) /\ ((@IN _114934 y _66841) /\ ((f x) = (f y)))) -> x = y).
Lemma le_c_def {_114929 _114934 : Type'} : (@le_c _114929 _114934) = (fun _66841 : _114934 -> Prop => fun _66842 : _114929 -> Prop => exists f : _114934 -> _114929, (forall x : _114934, (@IN _114934 x _66841) -> @IN _114929 (f x) _66842) /\ (forall x : _114934, forall y : _114934, ((@IN _114934 x _66841) /\ ((@IN _114934 y _66841) /\ ((f x) = (f y)))) -> x = y)).
Proof. exact (eq_refl (@le_c _114929 _114934)). Qed.
Definition lt_c {_114946 _114947 : Type'} : (_114946 -> Prop) -> (_114947 -> Prop) -> Prop := fun _66853 : _114946 -> Prop => fun _66854 : _114947 -> Prop => (@le_c _114947 _114946 _66853 _66854) /\ (~ (@le_c _114946 _114947 _66854 _66853)).
Lemma lt_c_def {_114946 _114947 : Type'} : (@lt_c _114946 _114947) = (fun _66853 : _114946 -> Prop => fun _66854 : _114947 -> Prop => (@le_c _114947 _114946 _66853 _66854) /\ (~ (@le_c _114946 _114947 _66854 _66853))).
Proof. exact (eq_refl (@lt_c _114946 _114947)). Qed.
Definition eq_c {_114995 _114998 : Type'} : (_114998 -> Prop) -> (_114995 -> Prop) -> Prop := fun _66865 : _114998 -> Prop => fun _66866 : _114995 -> Prop => exists f : _114998 -> _114995, (forall x : _114998, (@IN _114998 x _66865) -> @IN _114995 (f x) _66866) /\ (forall y : _114995, (@IN _114995 y _66866) -> @ex1 _114998 (fun x : _114998 => (@IN _114998 x _66865) /\ ((f x) = y))).
Lemma eq_c_def {_114995 _114998 : Type'} : (@eq_c _114995 _114998) = (fun _66865 : _114998 -> Prop => fun _66866 : _114995 -> Prop => exists f : _114998 -> _114995, (forall x : _114998, (@IN _114998 x _66865) -> @IN _114995 (f x) _66866) /\ (forall y : _114995, (@IN _114995 y _66866) -> @ex1 _114998 (fun x : _114998 => (@IN _114998 x _66865) /\ ((f x) = y)))).
Proof. exact (eq_refl (@eq_c _114995 _114998)). Qed.
Definition ge_c {_115006 _115007 : Type'} : (_115007 -> Prop) -> (_115006 -> Prop) -> Prop := fun _66877 : _115007 -> Prop => fun _66878 : _115006 -> Prop => @le_c _115007 _115006 _66878 _66877.
Lemma ge_c_def {_115006 _115007 : Type'} : (@ge_c _115006 _115007) = (fun _66877 : _115007 -> Prop => fun _66878 : _115006 -> Prop => @le_c _115007 _115006 _66878 _66877).
Proof. exact (eq_refl (@ge_c _115006 _115007)). Qed.
Definition gt_c {_115015 _115016 : Type'} : (_115016 -> Prop) -> (_115015 -> Prop) -> Prop := fun _66889 : _115016 -> Prop => fun _66890 : _115015 -> Prop => @lt_c _115015 _115016 _66890 _66889.
Lemma gt_c_def {_115015 _115016 : Type'} : (@gt_c _115015 _115016) = (fun _66889 : _115016 -> Prop => fun _66890 : _115015 -> Prop => @lt_c _115015 _115016 _66890 _66889).
Proof. exact (eq_refl (@gt_c _115015 _115016)). Qed.
Definition COUNTABLE {_115106 : Type'} : (_115106 -> Prop) -> Prop := fun _67040 : _115106 -> Prop => @ge_c _115106 nat (@UNIV nat) _67040.
Lemma COUNTABLE_def {_115106 : Type'} : (@COUNTABLE _115106) = (fun _67040 : _115106 -> Prop => @ge_c _115106 nat (@UNIV nat) _67040).
Proof. exact (eq_refl (@COUNTABLE _115106)). Qed.
Definition sup : (real -> Prop) -> real := fun _67045 : real -> Prop => @ε real (fun a : real => (forall x : real, (@IN real x _67045) -> real_le x a) /\ (forall b : real, (forall x : real, (@IN real x _67045) -> real_le x b) -> real_le a b)).
Lemma sup_def : sup = (fun _67045 : real -> Prop => @ε real (fun a : real => (forall x : real, (@IN real x _67045) -> real_le x a) /\ (forall b : real, (forall x : real, (@IN real x _67045) -> real_le x b) -> real_le a b))).
Proof. exact (eq_refl sup). Qed.
Definition inf : (real -> Prop) -> real := fun _67904 : real -> Prop => @ε real (fun a : real => (forall x : real, (@IN real x _67904) -> real_le a x) /\ (forall b : real, (forall x : real, (@IN real x _67904) -> real_le b x) -> real_le b a)).
Lemma inf_def : inf = (fun _67904 : real -> Prop => @ε real (fun a : real => (forall x : real, (@IN real x _67904) -> real_le a x) /\ (forall b : real, (forall x : real, (@IN real x _67904) -> real_le b x) -> real_le b a))).
Proof. exact (eq_refl inf). Qed.
Definition has_inf : (real -> Prop) -> real -> Prop := fun _69254 : real -> Prop => fun _69255 : real => forall c : real, (forall x : real, (@IN real x _69254) -> real_le c x) = (real_le c _69255).
Lemma has_inf_def : has_inf = (fun _69254 : real -> Prop => fun _69255 : real => forall c : real, (forall x : real, (@IN real x _69254) -> real_le c x) = (real_le c _69255)).
Proof. exact (eq_refl has_inf). Qed.
Definition has_sup : (real -> Prop) -> real -> Prop := fun _69266 : real -> Prop => fun _69267 : real => forall c : real, (forall x : real, (@IN real x _69266) -> real_le x c) = (real_le _69267 c).
Lemma has_sup_def : has_sup = (fun _69266 : real -> Prop => fun _69267 : real => forall c : real, (forall x : real, (@IN real x _69266) -> real_le x c) = (real_le _69267 c)).
Proof. exact (eq_refl has_sup). Qed.
Definition dotdot : nat -> nat -> nat -> Prop := fun _69692 : nat => fun _69693 : nat => @GSPEC nat (fun GEN_PVAR_229 : nat => exists x : nat, @SETSPEC nat GEN_PVAR_229 ((Peano.le _69692 x) /\ (Peano.le x _69693)) x).
Lemma dotdot_def : dotdot = (fun _69692 : nat => fun _69693 : nat => @GSPEC nat (fun GEN_PVAR_229 : nat => exists x : nat, @SETSPEC nat GEN_PVAR_229 ((Peano.le _69692 x) /\ (Peano.le x _69693)) x)).
Proof. exact (eq_refl dotdot). Qed.
Definition neutral {_119565 : Type'} : (_119565 -> _119565 -> _119565) -> _119565 := fun _71604 : _119565 -> _119565 -> _119565 => @ε _119565 (fun x : _119565 => forall y : _119565, ((_71604 x y) = y) /\ ((_71604 y x) = y)).
Lemma neutral_def {_119565 : Type'} : (@neutral _119565) = (fun _71604 : _119565 -> _119565 -> _119565 => @ε _119565 (fun x : _119565 => forall y : _119565, ((_71604 x y) = y) /\ ((_71604 y x) = y))).
Proof. exact (eq_refl (@neutral _119565)). Qed.
Definition monoidal {A : Type'} : (A -> A -> A) -> Prop := fun _71609 : A -> A -> A => (forall x : A, forall y : A, (_71609 x y) = (_71609 y x)) /\ ((forall x : A, forall y : A, forall z : A, (_71609 x (_71609 y z)) = (_71609 (_71609 x y) z)) /\ (forall x : A, (_71609 (@neutral A _71609) x) = x)).
Lemma monoidal_def {A : Type'} : (@monoidal A) = (fun _71609 : A -> A -> A => (forall x : A, forall y : A, (_71609 x y) = (_71609 y x)) /\ ((forall x : A, forall y : A, forall z : A, (_71609 x (_71609 y z)) = (_71609 (_71609 x y) z)) /\ (forall x : A, (_71609 (@neutral A _71609) x) = x))).
Proof. exact (eq_refl (@monoidal A)). Qed.
Definition support {A B : Type'} : (B -> B -> B) -> (A -> B) -> (A -> Prop) -> A -> Prop := fun _71694 : B -> B -> B => fun _71695 : A -> B => fun _71696 : A -> Prop => @GSPEC A (fun GEN_PVAR_237 : A => exists x : A, @SETSPEC A GEN_PVAR_237 ((@IN A x _71696) /\ (~ ((_71695 x) = (@neutral B _71694)))) x).
Lemma support_def {A B : Type'} : (@support A B) = (fun _71694 : B -> B -> B => fun _71695 : A -> B => fun _71696 : A -> Prop => @GSPEC A (fun GEN_PVAR_237 : A => exists x : A, @SETSPEC A GEN_PVAR_237 ((@IN A x _71696) /\ (~ ((_71695 x) = (@neutral B _71694)))) x)).
Proof. exact (eq_refl (@support A B)). Qed.
Definition iterate {_119779 A : Type'} : (_119779 -> _119779 -> _119779) -> (A -> Prop) -> (A -> _119779) -> _119779 := fun _71715 : _119779 -> _119779 -> _119779 => fun _71716 : A -> Prop => fun _71717 : A -> _119779 => @COND _119779 (@FINITE A (@support A _119779 _71715 _71717 _71716)) (@ITSET _119779 A (fun x : A => fun a : _119779 => _71715 (_71717 x) a) (@support A _119779 _71715 _71717 _71716) (@neutral _119779 _71715)) (@neutral _119779 _71715).
Lemma iterate_def {_119779 A : Type'} : (@iterate _119779 A) = (fun _71715 : _119779 -> _119779 -> _119779 => fun _71716 : A -> Prop => fun _71717 : A -> _119779 => @COND _119779 (@FINITE A (@support A _119779 _71715 _71717 _71716)) (@ITSET _119779 A (fun x : A => fun a : _119779 => _71715 (_71717 x) a) (@support A _119779 _71715 _71717 _71716) (@neutral _119779 _71715)) (@neutral _119779 _71715)).
Proof. exact (eq_refl (@iterate _119779 A)). Qed.
Definition iterato {A K : Type'} : (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A) (fun itty : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A => forall _80078 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))), forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall k : K -> Prop, forall f : K -> A, (itty _80078 dom neut op ltle k f) = (@COND A ((@FINITE K (@GSPEC K (fun GEN_PVAR_263 : K => exists i : K, @SETSPEC K GEN_PVAR_263 ((@IN K i k) /\ (@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A))))) i))) /\ (~ ((@GSPEC K (fun GEN_PVAR_264 : K => exists i : K, @SETSPEC K GEN_PVAR_264 ((@IN K i k) /\ (@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A))))) i)) = (@EMPTY K)))) (@LET K A (fun i : K => @LET_END A (op (f i) (itty _80078 dom neut op ltle (@GSPEC K (fun GEN_PVAR_265 : K => exists j : K, @SETSPEC K GEN_PVAR_265 ((@IN K j (@DELETE K k i)) /\ (@IN A (f j) (@DIFF A dom (@INSERT A neut (@EMPTY A))))) j)) f))) (@COND K (exists i : K, (@IN K i k) /\ ((@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@DIFF A dom (@INSERT A neut (@EMPTY A)))))) -> j = i))) (@ε K (fun i : K => (@IN K i k) /\ ((@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@DIFF A dom (@INSERT A neut (@EMPTY A)))))) -> j = i)))) (@ε K (fun i : K => (@IN K i k) /\ (@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A)))))))) neut)) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))))))))).
Lemma iterato_def {A K : Type'} : (@iterato A K) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A) (fun itty : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A => forall _80078 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))), forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall k : K -> Prop, forall f : K -> A, (itty _80078 dom neut op ltle k f) = (@COND A ((@FINITE K (@GSPEC K (fun GEN_PVAR_263 : K => exists i : K, @SETSPEC K GEN_PVAR_263 ((@IN K i k) /\ (@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A))))) i))) /\ (~ ((@GSPEC K (fun GEN_PVAR_264 : K => exists i : K, @SETSPEC K GEN_PVAR_264 ((@IN K i k) /\ (@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A))))) i)) = (@EMPTY K)))) (@LET K A (fun i : K => @LET_END A (op (f i) (itty _80078 dom neut op ltle (@GSPEC K (fun GEN_PVAR_265 : K => exists j : K, @SETSPEC K GEN_PVAR_265 ((@IN K j (@DELETE K k i)) /\ (@IN A (f j) (@DIFF A dom (@INSERT A neut (@EMPTY A))))) j)) f))) (@COND K (exists i : K, (@IN K i k) /\ ((@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@DIFF A dom (@INSERT A neut (@EMPTY A)))))) -> j = i))) (@ε K (fun i : K => (@IN K i k) /\ ((@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@DIFF A dom (@INSERT A neut (@EMPTY A)))))) -> j = i)))) (@ε K (fun i : K => (@IN K i k) /\ (@IN A (f i) (@DIFF A dom (@INSERT A neut (@EMPTY A)))))))) neut)) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 0))))))))))))))).
Proof. exact (eq_refl (@iterato A K)). Qed.
Definition nproduct {_126105 : Type'} : (_126105 -> Prop) -> (_126105 -> nat) -> nat := @iterate nat _126105 Nat.mul.
Lemma nproduct_def {_126105 : Type'} : (@nproduct _126105) = (@iterate nat _126105 Nat.mul).
Proof. exact (eq_refl (@nproduct _126105)). Qed.
Definition iproduct {_126180 : Type'} : (_126180 -> Prop) -> (_126180 -> int) -> int := @iterate int _126180 int_mul.
Lemma iproduct_def {_126180 : Type'} : (@iproduct _126180) = (@iterate int _126180 int_mul).
Proof. exact (eq_refl (@iproduct _126180)). Qed.
Definition product {_126259 : Type'} : (_126259 -> Prop) -> (_126259 -> real) -> real := @iterate real _126259 real_mul.
Lemma product_def {_126259 : Type'} : (@product _126259) = (@iterate real _126259 real_mul).
Proof. exact (eq_refl (@product _126259)). Qed.
Definition isum {_126338 : Type'} : (_126338 -> Prop) -> (_126338 -> int) -> int := @iterate int _126338 int_add.
Lemma isum_def {_126338 : Type'} : (@isum _126338) = (@iterate int _126338 int_add).
Proof. exact (eq_refl (@isum _126338)). Qed.
Definition nsum {_126417 : Type'} : (_126417 -> Prop) -> (_126417 -> nat) -> nat := @iterate nat _126417 Nat.add.
Lemma nsum_def {_126417 : Type'} : (@nsum _126417) = (@iterate nat _126417 Nat.add).
Proof. exact (eq_refl (@nsum _126417)). Qed.
Definition sum {_131408 : Type'} : (_131408 -> Prop) -> (_131408 -> real) -> real := @iterate real _131408 real_add.
Lemma sum_def {_131408 : Type'} : (@sum _131408) = (@iterate real _131408 real_add).
Proof. exact (eq_refl (@sum _131408)). Qed.
Definition polynomial_function : (real -> real) -> Prop := fun _97553 : real -> real => exists m : nat, exists c : nat -> real, forall x : real, (_97553 x) = (@sum nat (dotdot (NUMERAL 0) m) (fun i : nat => real_mul (c i) (real_pow x i))).
Lemma polynomial_function_def : polynomial_function = (fun _97553 : real -> real => exists m : nat, exists c : nat -> real, forall x : real, (_97553 x) = (@sum nat (dotdot (NUMERAL 0) m) (fun i : nat => real_mul (c i) (real_pow x i)))).
Proof. exact (eq_refl polynomial_function). Qed.
Definition dimindex {A : Type'} : (A -> Prop) -> nat := fun _97595 : A -> Prop => @COND nat (@FINITE A (@UNIV A)) (@CARD A (@UNIV A)) (NUMERAL (BIT1 0)).
Lemma dimindex_def {A : Type'} : (@dimindex A) = (fun _97595 : A -> Prop => @COND nat (@FINITE A (@UNIV A)) (@CARD A (@UNIV A)) (NUMERAL (BIT1 0))).
Proof. exact (eq_refl (@dimindex A)). Qed.
Axiom finite_index : forall {A : Type'}, nat -> finite_image A.
Axiom dest_finite_image : forall {A : Type'}, (finite_image A) -> nat.
Axiom mk_cart : forall {A B : Type'}, ((finite_image B) -> A) -> cart A B.
Axiom dest_cart : forall {A B : Type'}, (cart A B) -> (finite_image B) -> A.
Definition dollar {_139760 _139770 : Type'} : (cart _139760 _139770) -> nat -> _139760 := fun _98029 : cart _139760 _139770 => fun _98030 : nat => @dest_cart _139760 _139770 _98029 (@finite_index _139770 _98030).
Lemma dollar_def {_139760 _139770 : Type'} : (@dollar _139760 _139770) = (fun _98029 : cart _139760 _139770 => fun _98030 : nat => @dest_cart _139760 _139770 _98029 (@finite_index _139770 _98030)).
Proof. exact (eq_refl (@dollar _139760 _139770)). Qed.
Definition lambda {A B : Type'} : (nat -> A) -> cart A B := fun _98065 : nat -> A => @ε (cart A B) (fun f : cart A B => forall i : nat, ((Peano.le (NUMERAL (BIT1 0)) i) /\ (Peano.le i (@dimindex B (@UNIV B)))) -> (@dollar A B f i) = (_98065 i)).
Lemma lambda_def {A B : Type'} : (@lambda A B) = (fun _98065 : nat -> A => @ε (cart A B) (fun f : cart A B => forall i : nat, ((Peano.le (NUMERAL (BIT1 0)) i) /\ (Peano.le i (@dimindex B (@UNIV B)))) -> (@dollar A B f i) = (_98065 i))).
Proof. exact (eq_refl (@lambda A B)). Qed.
Axiom mk_finite_sum : forall {A B : Type'}, nat -> finite_sum A B.
Axiom dest_finite_sum : forall {A B : Type'}, (finite_sum A B) -> nat.
Definition pastecart {A M N : Type'} : (cart A M) -> (cart A N) -> cart A (finite_sum M N) := fun _98356 : cart A M => fun _98357 : cart A N => @lambda A (finite_sum M N) (fun i : nat => @COND A (Peano.le i (@dimindex M (@UNIV M))) (@dollar A M _98356 i) (@dollar A N _98357 (Nat.sub i (@dimindex M (@UNIV M))))).
Lemma pastecart_def {A M N : Type'} : (@pastecart A M N) = (fun _98356 : cart A M => fun _98357 : cart A N => @lambda A (finite_sum M N) (fun i : nat => @COND A (Peano.le i (@dimindex M (@UNIV M))) (@dollar A M _98356 i) (@dollar A N _98357 (Nat.sub i (@dimindex M (@UNIV M)))))).
Proof. exact (eq_refl (@pastecart A M N)). Qed.
Definition fstcart {A M N : Type'} : (cart A (finite_sum M N)) -> cart A M := fun _98368 : cart A (finite_sum M N) => @lambda A M (fun i : nat => @dollar A (finite_sum M N) _98368 i).
Lemma fstcart_def {A M N : Type'} : (@fstcart A M N) = (fun _98368 : cart A (finite_sum M N) => @lambda A M (fun i : nat => @dollar A (finite_sum M N) _98368 i)).
Proof. exact (eq_refl (@fstcart A M N)). Qed.
Definition sndcart {A M N : Type'} : (cart A (finite_sum M N)) -> cart A N := fun _98373 : cart A (finite_sum M N) => @lambda A N (fun i : nat => @dollar A (finite_sum M N) _98373 (Nat.add i (@dimindex M (@UNIV M)))).
Lemma sndcart_def {A M N : Type'} : (@sndcart A M N) = (fun _98373 : cart A (finite_sum M N) => @lambda A N (fun i : nat => @dollar A (finite_sum M N) _98373 (Nat.add i (@dimindex M (@UNIV M))))).
Proof. exact (eq_refl (@sndcart A M N)). Qed.
Axiom mk_finite_diff : forall {A B : Type'}, nat -> finite_diff A B.
Axiom dest_finite_diff : forall {A B : Type'}, (finite_diff A B) -> nat.
Axiom mk_finite_prod : forall {A B : Type'}, nat -> finite_prod A B.
Axiom dest_finite_prod : forall {A B : Type'}, (finite_prod A B) -> nat.
Axiom _mk_tybit0 : forall {A : Type'}, (recspace (finite_sum A A)) -> tybit0 A.
Axiom _dest_tybit0 : forall {A : Type'}, (tybit0 A) -> recspace (finite_sum A A).
Definition _103783 {A : Type'} : (finite_sum A A) -> tybit0 A := fun a : finite_sum A A => @_mk_tybit0 A ((fun a' : finite_sum A A => @CONSTR (finite_sum A A) (NUMERAL 0) a' (fun n : nat => @BOTTOM (finite_sum A A))) a).
Lemma _103783_def {A : Type'} : (@_103783 A) = (fun a : finite_sum A A => @_mk_tybit0 A ((fun a' : finite_sum A A => @CONSTR (finite_sum A A) (NUMERAL 0) a' (fun n : nat => @BOTTOM (finite_sum A A))) a)).
Proof. exact (eq_refl (@_103783 A)). Qed.
Definition mktybit0 {A : Type'} : (finite_sum A A) -> tybit0 A := @_103783 A.
Lemma mktybit0_def {A : Type'} : (@mktybit0 A) = (@_103783 A).
Proof. exact (eq_refl (@mktybit0 A)). Qed.
Axiom _mk_tybit1 : forall {A : Type'}, (recspace (finite_sum (finite_sum A A) unit)) -> tybit1 A.
Axiom _dest_tybit1 : forall {A : Type'}, (tybit1 A) -> recspace (finite_sum (finite_sum A A) unit).
Definition _103802 {A : Type'} : (finite_sum (finite_sum A A) unit) -> tybit1 A := fun a : finite_sum (finite_sum A A) unit => @_mk_tybit1 A ((fun a' : finite_sum (finite_sum A A) unit => @CONSTR (finite_sum (finite_sum A A) unit) (NUMERAL 0) a' (fun n : nat => @BOTTOM (finite_sum (finite_sum A A) unit))) a).
Lemma _103802_def {A : Type'} : (@_103802 A) = (fun a : finite_sum (finite_sum A A) unit => @_mk_tybit1 A ((fun a' : finite_sum (finite_sum A A) unit => @CONSTR (finite_sum (finite_sum A A) unit) (NUMERAL 0) a' (fun n : nat => @BOTTOM (finite_sum (finite_sum A A) unit))) a)).
Proof. exact (eq_refl (@_103802 A)). Qed.
Definition mktybit1 {A : Type'} : (finite_sum (finite_sum A A) unit) -> tybit1 A := @_103802 A.
Lemma mktybit1_def {A : Type'} : (@mktybit1 A) = (@_103802 A).
Proof. exact (eq_refl (@mktybit1 A)). Qed.
Definition vector {A N : Type'} : (list A) -> cart A N := fun _105592 : list A => @lambda A N (fun i : nat => @EL A (Nat.sub i (NUMERAL (BIT1 0))) _105592).
Lemma vector_def {A N : Type'} : (@vector A N) = (fun _105592 : list A => @lambda A N (fun i : nat => @EL A (Nat.sub i (NUMERAL (BIT1 0))) _105592)).
Proof. exact (eq_refl (@vector A N)). Qed.
Definition PCROSS {A M N : Type'} : ((cart A M) -> Prop) -> ((cart A N) -> Prop) -> (cart A (finite_sum M N)) -> Prop := fun _105619 : (cart A M) -> Prop => fun _105620 : (cart A N) -> Prop => @GSPEC (cart A (finite_sum M N)) (fun GEN_PVAR_361 : cart A (finite_sum M N) => exists x : cart A M, exists y : cart A N, @SETSPEC (cart A (finite_sum M N)) GEN_PVAR_361 ((@IN (cart A M) x _105619) /\ (@IN (cart A N) y _105620)) (@pastecart A M N x y)).
Lemma PCROSS_def {A M N : Type'} : (@PCROSS A M N) = (fun _105619 : (cart A M) -> Prop => fun _105620 : (cart A N) -> Prop => @GSPEC (cart A (finite_sum M N)) (fun GEN_PVAR_361 : cart A (finite_sum M N) => exists x : cart A M, exists y : cart A N, @SETSPEC (cart A (finite_sum M N)) GEN_PVAR_361 ((@IN (cart A M) x _105619) /\ (@IN (cart A N) y _105620)) (@pastecart A M N x y))).
Proof. exact (eq_refl (@PCROSS A M N)). Qed.
Definition CASEWISE {_143118 _143154 _143158 _143159 : Type'} : (list (prod (_143154 -> _143158) (_143159 -> _143154 -> _143118))) -> _143159 -> _143158 -> _143118 := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (list (prod (_143154 -> _143158) (_143159 -> _143154 -> _143118))) -> _143159 -> _143158 -> _143118) (fun CASEWISE' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (list (prod (_143154 -> _143158) (_143159 -> _143154 -> _143118))) -> _143159 -> _143158 -> _143118 => forall _106222 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))), (forall f : _143159, forall x : _143158, (CASEWISE' _106222 (@nil (prod (_143154 -> _143158) (_143159 -> _143154 -> _143118))) f x) = (@ε _143118 (fun y : _143118 => True))) /\ (forall h : prod (_143154 -> _143158) (_143159 -> _143154 -> _143118), forall t : list (prod (_143154 -> _143158) (_143159 -> _143154 -> _143118)), forall f : _143159, forall x : _143158, (CASEWISE' _106222 (@cons (prod (_143154 -> _143158) (_143159 -> _143154 -> _143118)) h t) f x) = (@COND _143118 (exists y : _143154, (@fst (_143154 -> _143158) (_143159 -> _143154 -> _143118) h y) = x) (@snd (_143154 -> _143158) (_143159 -> _143154 -> _143118) h f (@ε _143154 (fun y : _143154 => (@fst (_143154 -> _143158) (_143159 -> _143154 -> _143118) h y) = x))) (CASEWISE' _106222 t f x)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0))))))))))))))).
Lemma CASEWISE_def {_143118 _143154 _143158 _143159 : Type'} : (@CASEWISE _143118 _143154 _143158 _143159) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (list (prod (_143154 -> _143158) (_143159 -> _143154 -> _143118))) -> _143159 -> _143158 -> _143118) (fun CASEWISE' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (list (prod (_143154 -> _143158) (_143159 -> _143154 -> _143118))) -> _143159 -> _143158 -> _143118 => forall _106222 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))), (forall f : _143159, forall x : _143158, (CASEWISE' _106222 (@nil (prod (_143154 -> _143158) (_143159 -> _143154 -> _143118))) f x) = (@ε _143118 (fun y : _143118 => True))) /\ (forall h : prod (_143154 -> _143158) (_143159 -> _143154 -> _143118), forall t : list (prod (_143154 -> _143158) (_143159 -> _143154 -> _143118)), forall f : _143159, forall x : _143158, (CASEWISE' _106222 (@cons (prod (_143154 -> _143158) (_143159 -> _143154 -> _143118)) h t) f x) = (@COND _143118 (exists y : _143154, (@fst (_143154 -> _143158) (_143159 -> _143154 -> _143118) h y) = x) (@snd (_143154 -> _143158) (_143159 -> _143154 -> _143118) h f (@ε _143154 (fun y : _143154 => (@fst (_143154 -> _143158) (_143159 -> _143154 -> _143118) h y) = x))) (CASEWISE' _106222 t f x)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 0)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 0)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 0)))))))))))))))).
Proof. exact (eq_refl (@CASEWISE _143118 _143154 _143158 _143159)). Qed.
Definition admissible {_143449 _143452 _143456 _143457 _143462 : Type'} : (_143456 -> _143449 -> Prop) -> ((_143456 -> _143452) -> _143462 -> Prop) -> (_143462 -> _143449) -> ((_143456 -> _143452) -> _143462 -> _143457) -> Prop := fun _107289 : _143456 -> _143449 -> Prop => fun _107290 : (_143456 -> _143452) -> _143462 -> Prop => fun _107291 : _143462 -> _143449 => fun _107292 : (_143456 -> _143452) -> _143462 -> _143457 => forall f : _143456 -> _143452, forall g : _143456 -> _143452, forall a : _143462, ((_107290 f a) /\ ((_107290 g a) /\ (forall z : _143456, (_107289 z (_107291 a)) -> (f z) = (g z)))) -> (_107292 f a) = (_107292 g a).
Lemma admissible_def {_143449 _143452 _143456 _143457 _143462 : Type'} : (@admissible _143449 _143452 _143456 _143457 _143462) = (fun _107289 : _143456 -> _143449 -> Prop => fun _107290 : (_143456 -> _143452) -> _143462 -> Prop => fun _107291 : _143462 -> _143449 => fun _107292 : (_143456 -> _143452) -> _143462 -> _143457 => forall f : _143456 -> _143452, forall g : _143456 -> _143452, forall a : _143462, ((_107290 f a) /\ ((_107290 g a) /\ (forall z : _143456, (_107289 z (_107291 a)) -> (f z) = (g z)))) -> (_107292 f a) = (_107292 g a)).
Proof. exact (eq_refl (@admissible _143449 _143452 _143456 _143457 _143462)). Qed.
Definition tailadmissible {A B P : Type'} : (A -> A -> Prop) -> ((A -> B) -> P -> Prop) -> (P -> A) -> ((A -> B) -> P -> B) -> Prop := fun _107321 : A -> A -> Prop => fun _107322 : (A -> B) -> P -> Prop => fun _107323 : P -> A => fun _107324 : (A -> B) -> P -> B => exists P' : (A -> B) -> P -> Prop, exists G : (A -> B) -> P -> A, exists H : (A -> B) -> P -> B, (forall f : A -> B, forall a : P, forall y : A, ((P' f a) /\ (_107321 y (G f a))) -> _107321 y (_107323 a)) /\ ((forall f : A -> B, forall g : A -> B, forall a : P, (forall z : A, (_107321 z (_107323 a)) -> (f z) = (g z)) -> ((P' f a) = (P' g a)) /\ (((G f a) = (G g a)) /\ ((H f a) = (H g a)))) /\ (forall f : A -> B, forall a : P, (_107322 f a) -> (_107324 f a) = (@COND B (P' f a) (f (G f a)) (H f a)))).
Lemma tailadmissible_def {A B P : Type'} : (@tailadmissible A B P) = (fun _107321 : A -> A -> Prop => fun _107322 : (A -> B) -> P -> Prop => fun _107323 : P -> A => fun _107324 : (A -> B) -> P -> B => exists P' : (A -> B) -> P -> Prop, exists G : (A -> B) -> P -> A, exists H : (A -> B) -> P -> B, (forall f : A -> B, forall a : P, forall y : A, ((P' f a) /\ (_107321 y (G f a))) -> _107321 y (_107323 a)) /\ ((forall f : A -> B, forall g : A -> B, forall a : P, (forall z : A, (_107321 z (_107323 a)) -> (f z) = (g z)) -> ((P' f a) = (P' g a)) /\ (((G f a) = (G g a)) /\ ((H f a) = (H g a)))) /\ (forall f : A -> B, forall a : P, (_107322 f a) -> (_107324 f a) = (@COND B (P' f a) (f (G f a)) (H f a))))).
Proof. exact (eq_refl (@tailadmissible A B P)). Qed.
Definition superadmissible {_143606 _143608 _143614 : Type'} : (_143606 -> _143606 -> Prop) -> ((_143606 -> _143608) -> _143614 -> Prop) -> (_143614 -> _143606) -> ((_143606 -> _143608) -> _143614 -> _143608) -> Prop := fun _107353 : _143606 -> _143606 -> Prop => fun _107354 : (_143606 -> _143608) -> _143614 -> Prop => fun _107355 : _143614 -> _143606 => fun _107356 : (_143606 -> _143608) -> _143614 -> _143608 => (@admissible _143606 _143608 _143606 Prop _143614 _107353 (fun f : _143606 -> _143608 => fun a : _143614 => True) _107355 _107354) -> @tailadmissible _143606 _143608 _143614 _107353 _107354 _107355 _107356.
Lemma superadmissible_def {_143606 _143608 _143614 : Type'} : (@superadmissible _143606 _143608 _143614) = (fun _107353 : _143606 -> _143606 -> Prop => fun _107354 : (_143606 -> _143608) -> _143614 -> Prop => fun _107355 : _143614 -> _143606 => fun _107356 : (_143606 -> _143608) -> _143614 -> _143608 => (@admissible _143606 _143608 _143606 Prop _143614 _107353 (fun f : _143606 -> _143608 => fun a : _143614 => True) _107355 _107354) -> @tailadmissible _143606 _143608 _143614 _107353 _107354 _107355 _107356).
Proof. exact (eq_refl (@superadmissible _143606 _143608 _143614)). Qed.
